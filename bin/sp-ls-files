#!/bin/sh

# Serval Project Git source file list utility
# Copyright 2012 Andrew Bettison
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


# A wrapper around git ls-files that crosses submodule boundaries.

default_git_options="--exclude-standard --cached --other"

usage() {
   echo "\
Usage: ${0##*/} [--no-submodules] [git-options] [--] [args]
       ${0##*/} [-S|--submodules] [git-options] [--]
Options:
   -S, --submodules  list all files in all submodules of the outermost
                     Git repository
   --no-submodules   only list files within the current git repostory
                     [default]
   --help            print this message and exit
   git-options       all other options are passed directly to the
                     'git ls-files' command; if none given, then passes
                     $default_git_options
Args:
   Passed verbatim to the 'git ls-files' command.
"
}

submodules=false
opt_submodules=
git_options=
while [ $# -ne 0 ]
do
   case "$1" in
   --help) usage; exit 0;;
   --submodules|-S) opt_submodules="$1"; submodules=true; shift;;
   --no-submodules) opt_submodules="$1"; submodules=false; shift;;
   -*) git_options="$git_options $1"; shift;;
   --) shift; break;;
   *) break;;
   esac
done
[ -z "$git_options" ] && git_options="$default_git_options"

# Find all enclosing Git repos of the given path (file or directory), from
# smallest (probably a submodule) to the largest.
find_git_roots() {
   (
      relative=false
      case "$1" in
      --relative) relative=true; shift;;
      esac
      if [ $# -ne 0 ]; then
         if [ -d "$1" ]; then
            cd "$1" >/dev/null || exit 1
         else
            case "$1" in
            */*) cd "${1%/*}" >/dev/null || exit 1;;
            esac
         fi
      fi
      REL=
      while [ "$PWD" != / ]; do
         if [ -r ".git/config" ]; then
            if $relative; then echo "$REL"; else echo "$PWD"; fi
         fi
         REL="$REL${REL:+/}.."
         cd .. >/dev/null || exit 1
      done
   )
}

tmp="/tmp/${0##*/}-$$"
trap 'stat=$?; rm -f "$tmp"*; exit $stat' 0 1 2 15

# Assume that all paths given on the command line belong within the same Git
# repo, so use the first arg to find the repo root.  If no paths specified on
# the command line, then use the Git repo containing the current directory.
if [ $# -eq 0 ]; then
   if $submodules; then
      git_root=$(find_git_roots --relative "$arg" | sed -n '$p')
      export _prefix="${git_root:+$git_root/}"
      cd "$git_root" >/dev/null || exit 1
      git ls-files $git_options >"$tmp-f" || exit $?
      awk '{ print ENVIRON["_prefix"] $0 }' "$tmp-f"
      git submodule foreach --quiet --recursive git ls-files $git_options '|' 'path="$path"' awk \''{ print ENVIRON["_prefix"] ENVIRON["path"] "/" $0 }'\' #'
   else
      git ls-files $git_options || exit $?
   fi
else
   if $submodules; then
      echo "${0##*/}: cannot use $opt_submodules with arguments" >&2
      exit 1
   fi
   for arg; do
      cwd_git_root=$(find_git_roots | sed -n '1p')
      git_root=$(find_git_roots "$arg" | sed -n '1p')
      export _prefix=
      if [ "$git_root" != "$cwd_git_root" ]; then
         if [ -d "$arg" ]; then
            cd "$arg" >/dev/null || exit 1
            export _prefix="$arg/"
            arg=.
         else
            case "$arg" in
            */*)
               cd "${arg%/*}" >/dev/null || exit 1
               export _prefix="${arg%/*}/"
               arg="${arg##*/}"
               ;;
            *)
               echo "${0##*/}: that's wierd: arg='$arg'" >&2
               exit 1
               ;;
            esac
         fi
      fi
      git ls-files $git_options "$arg" >"$tmp-f" || exit $?
      awk '{ print ENVIRON["_prefix"] $0 }' "$tmp-f"
   done
fi
exit 0
