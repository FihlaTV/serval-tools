#!/usr/bin/env python

'''Usage:
    sp-mantis2github [options] mantis version
    sp-mantis2github [options] mantis wsdl
    sp-mantis2github [options] mantis list users
    sp-mantis2github [options] mantis list projects
    sp-mantis2github [options] mantis list issues [<project-id>] [-C|--closed] [-O|--open]
    sp-mantis2github [options] mantis dump project <project-id>
    sp-mantis2github [options] mantis dump issue <issue-id>
    sp-mantis2github [options] github register
    sp-mantis2github [options] github list users
    sp-mantis2github [options] github list repos
    sp-mantis2github [options] github list issues <repo-name>
    sp-mantis2github [options] github dump issue <repo-name> <issue-number>
    sp-mantis2github [options] migrate <issue-id> <repo-name>
    sp-mantis2github -h | --help
    sp-mantis2github --version
Options:
    -h --help               Show this message
    --version               Show version and exit
    -D --debug              Enable debug logging
    -n --dry-run            Do not write to GitHub, just perform all queries
    --config=PATH           Read config file [default: $HOME/.mantis2github]
    --mantis-url=URL        Connect to Mantis SOAP service at this URL (default taken from
                            $SERVAL_MANTIS_URL/api/soap/mantisconnect.php if set, or config file)
    --mantis-user=USER      Connect to Mantis with this user name (overrides config file)
    --mantis-password=PASS  Connect to Mantis with this password (overrides config file)
    --github-user=USER      Connect to GitHub with this user name (overrides config file)
    --github-password=PASS  Connect to GitHub with this password (overrides config file)
    -C --closed             When listing issues, only include closed issues
    -O --open               When listing issues, only include open issues

The config file is in INI format.  It contains user names and passwords in the clear so it is ignored
unless owned by the caller and permissions are at most 0600.
'''

myname = 'sp-mantis2github'
myversion = '0.3'
debug = False

import sys
import traceback
import os
import os.path
import logging
import ConfigParser
import datetime
import suds
import urllib2
import re

def main():
    logging.basicConfig(level=logging.INFO)
    logging.getLogger('suds').setLevel(logging.CRITICAL)
    sys.path.append(os.path.join(serval_tools_root(), "python/docopt"))
    sys.path.append(os.path.join(serval_tools_root(), "python/PyGithub"))
    import docopt
    import github
    opts = docopt.docopt(__doc__, version=myversion)
    #print opts
    debug = False
    if opts['--debug']:
        debug = True
        logging.getLogger().setLevel(logging.DEBUG)
        logging.getLogger('suds').setLevel(logging.INFO)
    config = read_config_file(os.path.expanduser(os.path.expandvars(opts['--config'])))
    mantis_url = opts['--mantis-url']
    if not mantis_url:
        mantis_url = config.mantis_url or os.environ.get('SERVAL_MANTIS_URL')
        if mantis_url:
            mantis_url += '/api/soap/mantisconnect.php'
    mantis_user = opts['--mantis-user'] or config.mantis_user
    mantis_password = opts['--mantis-password'] or config.mantis_password
    github_user = opts['--github-user'] or config.github_user
    github_password = opts['--github-password'] or config.github_password
    try:
        if opts['mantis'] or opts['migrate']:
            if not mantis_url:
                fatal("missing Mantis URL")
            mc = suds.client.Client(mantis_url + '?wsdl')
        if opts['github'] or opts['migrate']:
            if github_user is None:
                fatal("missing GitHub user name")
            github_users = {}
            for login, token in config.github_users.iteritems():
                gh = GithubUser()
                gh.login = login
                logging.debug('connect to GitHub as %r' % (login,))
                gh.account = github.Github(token)
                gh.org = gh.account.get_organization('servalproject')
                github_users[login] = gh
        if opts['mantis']:
            if opts['wsdl']:
                print mc
                return
            if opts['version']:
                print soap_service(mc, 'mc_version')
                return
        if opts['mantis'] or opts['migrate']:
            if mantis_user is None:
                fatal("missing Mantis user name")
            if mantis_password is None:
                fatal("missing Mantis password")
            mantis_credentials={}
            mantis_credentials['username'] = mantis_user
            mantis_credentials['password'] = mantis_password
        if opts['mantis']:
            if opts['list'] and opts['projects']:
                projects = soap_service(mc, 'mc_projects_get_user_accessible', **mantis_credentials)
                projects.sort(key=lambda p: p.id)
                for project in projects:
                    print '%-5s %-15s %-15s %-40s' % (project.id, project.status.name, project.view_state.name, project.name)
                return
            if opts['dump'] and opts['project']:
                try:
                    project_id = int(opts['<project-id>'])
                except ValueError:
                    fatal('invalid <project-id>')
                projects = soap_service(mc, 'mc_projects_get_user_accessible', **mantis_credentials)
                for project in projects:
                    if project.id == project_id:
                        print project
                return
            if opts['dump'] and opts['issue']:
                try:
                    issue_id = int(opts['<issue-id>'])
                except ValueError:
                    fatal('invalid <issue-id>')
                print soap_service(mc, 'mc_issue_get', issue_id=issue_id, **mantis_credentials)
                return
            if opts['list'] and opts['users']:
                all_issues = mantis_get_issues(mc, **mantis_credentials)
                users = {}
                for issue in all_issues:
                    try:
                        users[issue.reporter.id] = issue.reporter
                    except AttributeError:
                        pass
                    try:
                        users[issue.handler.id] = issue.handler
                    except AttributeError:
                        pass
                users = users.values()
                users.sort(key=lambda u: (getattr(u, 'name', ''), getattr(u, 'real_name', '')))
                for user in users:
                    values = (getattr(user, 'name', ''), getattr(user, 'real_name', ''), getattr(user, 'email', ''))
                    if values != ('', '', ''):
                        print '%-20s %-30s %s' % values
                return
            if opts['list'] and opts['issues']:
                project_ids = []
                if opts['<project-id>']:
                    try:
                        project_ids.append(int(opts['<project-id>']))
                    except ValueError:
                        fatal('invalid <project-id>')
                all_issues = mantis_get_issues(mc, project_ids, **mantis_credentials)
                all_issues.sort(key=lambda p: p.id)
                for issue in all_issues:
                    resolutions = []
                    if opts['--open']:
                        resolutions += ['open', 'reopened']
                    if opts['--closed']:
                        resolutions += ['fixed']
                    if resolutions and issue.resolution.name not in resolutions:
                        continue
                    print '%-5s %-10s %s' % (issue.id, issue.resolution.name, issue.summary)
                return
        if opts['github']:
            if opts['register']:
                if github_password is None:
                    fatal("missing GitHub password")
                logging.debug('connect to GitHub as %r with password' % (github_user,))
                gha = github.Github(github_user, github_password)
                ghuser = gha.get_user()
                logging.debug('create GitHub authorization')
                if not opts['--dry-run']:
                    auth = ghuser.create_authorization(scopes=['public_repo'], note= myname + ' version ' + myversion)
                    print auth.token
                return
        if github_user not in github_users:
            fatal('missing token for GitHub user %r' % github_user)
        github_default_user = github_users.get(github_user) # Default user
        if opts['github']:
            if opts['list'] and opts['users']:
                users = list(github_default_user.org.get_members())
                users.sort(key=lambda u: (u.login, u.name))
                for user in users:
                    print '%-20s %-30s %s' % (user.login, user.name or '', user.email or '')
                return
            if opts['list'] and opts['repos']:
                repos = github_default_user.org.get_repos()
                for repo in repos:
                    print repo.name
                return
            repo_name = opts['<repo-name>']
            if opts['list'] and opts['issues']:
                repo = github_default_user.org.get_repo(repo_name)
                all_issues = []
                if opts['--open'] or not opts['--closed']:
                    all_issues += repo.get_issues(state='open')
                if opts['--closed'] or not opts['--open']:
                    all_issues += repo.get_issues(state='closed')
                all_issues.sort(key=lambda p: p.number)
                for issue in all_issues:
                    print '%-5s %-10s %s' % (issue.number, issue.state, issue.title)
                return
            if opts['dump'] and opts['issue']:
                try:
                    issue_number = int(opts['<issue-number>'])
                except ValueError:
                    fatal('invalid <issue-number>')
                repo = github_default_user.org.get_repo(repo_name)
                github_dump_issue(repo.get_issue(issue_number))
                return
        if opts['migrate']:
            mantis_url_base = mantis_url[:mantis_url.index('/api/')]
            try:
                issue_id = int(opts['<issue-id>'])
            except ValueError:
                fatal('invalid <issue-id>')
            repo_name = opts['<repo-name>']
            mantis_issue = soap_service(mc, 'mc_issue_get', issue_id=issue_id, **mantis_credentials)
            mantis_issue_url = mantis_url_base + '/view.php?id=' + str(mantis_issue.id)
            mantis_issue_number = '%07u' % mantis_issue.id
            mantis_link = '[mantis:' + mantis_issue_number + '](' + mantis_issue_url + ')'
            creator_gh, reporter_ref, reporter_tag = resolve_user(config, github_users, mantis_issue.reporter)
            if creator_gh is None:
                creator_gh = github_default_user
            creator_gh.repo = creator_gh.org.get_repo(repo_name)
            label_name = 'mantis2github'
            try:
                label = creator_gh.repo.get_label(label_name)
            except github.GithubException, e:
                if e.status == 404:
                    fatal('GitHub repo %r does not have label %r' % (repo_name, label_name))
                raise
            body = []
            if reporter_tag:
                body += [reporter_tag, ' reported:\n\n']
            body += [mantis_text_to_markdown(mantis_issue.description)]
            # This must be the first comment to make it easy to later detect and cross-reference Mantis
            # issues to GitHub issues.
            comments = [(creator_gh,
                    'Originally reported as **' + mantis_link + '**'
                    (' by ' + reporter_ref if reporter_ref else '') +
                    ' at ' + mantis_issue.date_submitted.ctime() + '.'
                )]
            github_assignee = None
            if hasattr(mantis_issue, 'handler') and mantis_issue.handler:
                github_assignee_login = config.user_map.get(mantis_issue.handler.name)
                if github_assignee_login:
                    github_assignee = github_default_user.account.get_user(github_assignee_login)
            body += ['\n\nCan reproduce: **', mantis_issue.reproducibility.name, '**']
            if hasattr(mantis_issue, 'steps_to_reproduce') and mantis_issue.steps_to_reproduce:
                body += ['\n\nTo reproduce:\n\n', mantis_text_to_markdown(mantis_issue.steps_to_reproduce)]
            if hasattr(mantis_issue, 'additional_information') and mantis_issue.additional_information:
                body += ['\n\n' + mantis_text_to_markdown(mantis_issue.additional_information)]
            createargs = {}
            createargs['title'] = unicode(mantis_issue.summary)
            createargs['body'] = u''.join(body)
            createargs['labels'] = [label]
            if hasattr(mantis_issue, 'notes') and mantis_issue.notes:
                for note in mantis_issue.notes:
                    noter_github, noter_ref, noter_tag = resolve_user(config, github_users, note.reporter)
                    body = []
                    body += ['At ', note.date_submitted.ctime()]
                    if noter_github is None:
                        noter_github = github_default_user
                        body += [' ', noter_tag, ' commented']
                    else:
                        noter_tag = None
                    body += [':']
                    if hasattr(note, 'time_tracking') and note.time_tracking:
                        hours = note.time_tracking / 60
                        minutes = note.time_tracking % 60
                        body += ['\n\nTime spent: **%u:%02u**' % (hours, minutes)]
                    if hasattr(note, 'text') and note.text:
                        body += ['\n\n', mantis_text_to_markdown(note.text)]
                    comments.append((noter_github, ''.join(body)))
            # TODO: close the issue before the migration comment
            comments.append((github_default_user,
                    'Issue migrated from Mantis to GitHub' +
                    ' at ' + datetime.datetime.now().ctime() +
                    ' using [' + myname + '](https://github.com/servalproject/serval-tools/blob/master/bin/' + myname + ') version ' + myversion + '.'
                ))
            logging.debug('GitHub login %r repo %r create_issue(title=%r body=%r labels=[%s])' % (
                    creator_gh.login,
                    creator_gh.repo.name,
                    createargs['title'],
                    createargs['body'],
                    ','.join(label.name for label in createargs['labels']),
                ))
            issue_number = None
            if not opts['--dry-run']:
                creator_gh.issue = creator_gh.repo.create_issue(**createargs)
                issue_number = creator_gh.issue.number
            if github_assignee is not None:
                logging.debug('GitHub login %r repo %r issue %r edit(assignee=%r)' % (creator_gh.login, creator_gh.repo.name, issue_number, github_assignee.login))
                if not opts['--dry-run']:
                    creator_gh.issue.edit(assignee=github_assignee)
            if creator_gh.issue is not None and creator_gh.issue.assignee is None:
                logging.warn('cannot assign issue to %r' % (github_assignee.login,))
                comments.insert(1, (github_default_user, 'Assigned to Mantis user ' + mantis_user_markdown(mantis_issue.handler) + '.'))
            for commenter_gh, comment in comments:
                if commenter_gh.repo is None:
                    commenter_gh.repo = commenter_gh.org.get_repo(repo_name)
                logging.debug('GitHub login %r repo %r issue %r create_comment(%r)' % (commenter_gh.login, commenter_gh.repo.name, issue_number, comment))
                if not opts['--dry-run']:
                    if commenter_gh.issue is None:
                        commenter_gh.issue = commenter_gh.repo.get_issue(issue_number)
                    commenter_gh.issue.create_comment(comment)
            # TODO: handle project
            # TODO: handle version and target version
            # TODO: handle severity
            # TODO: handle priority
            # TODO: handle tags
            # TODO: handle attachments (import as Gists?)
            # TODO: handle relationships (links between issues)
            #   - command to build map
            #   - cache map locally
            #   - command to edit comments referring to imported Mantis issues,
            #     to refer to GitHub issues instead
            return
    except suds.WebFault, e:
        if debug:
            traceback.print_exc()
        fatal(e)
    except IOError, e:
        if debug:
            traceback.print_exc()
        fatal('%s: %s' % (mantis_url or '<Unknown URL>', e))
    except github.GithubException, e:
        if debug:
            traceback.print_exc()
        fatal(e.data.get('message', 'Unknown error'))

def fatal(message):
    logging.critical(message)
    sys.exit(1)

def serval_tools_root():
    return os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))

class Config(object):
    mantis_url = None
    mantis_user = None
    mantis_password = None
    github_users = {}
    user_map = {}

class GithubUser(object):
    login = None
    account = None
    org = None
    repo = None
    issue = None

def read_config_file(path):
    config = Config()
    if os.path.exists(path):
        stat = os.stat(path)
        if stat.st_uid != os.getuid():
            logging.warn("%s exists but is owned by uid %s (should be %s)" % (path, stat.st_uid, getuid()))
        elif stat.st_mode & 0177:
            logging.warn("%s exists but has mode %#o (should be at most 0600)" % (path, stat.st_mode & 0777))
        else:
            try:
                cp = ConfigParser.SafeConfigParser()
                cp.optionxform = str
                cp.readfp(file(path))
                try:
                    config.mantis_url = cp.get('mantis', 'url', os.environ)
                except ConfigParser.NoOptionError:
                    pass
                try:
                    config.mantis_user = cp.get('mantis', 'user', os.environ)
                except ConfigParser.NoOptionError:
                    pass
                try:
                    config.mantis_password = cp.get('mantis', 'password', os.environ)
                except ConfigParser.NoOptionError:
                    pass
                try:
                    config.github_user = cp.get('github', 'user', os.environ)
                except ConfigParser.NoOptionError:
                    pass
                try:
                    config.github_password = cp.get('github', 'password', os.environ)
                except ConfigParser.NoOptionError:
                    pass
                config.github_users = {}
                for key, value in cp.items('github users'):
                    config.github_users[key] = cp.get('github users', key, os.environ)
                config.user_map = {}
                for key, value in cp.items('user map'):
                    config.user_map[key] = cp.get('user map', key, os.environ)
            except ValueError, e:
                logging.error('%s, line %d: malformed line' % (path, lnum))
            except IOError, e:
                logging.error(e)
    return config

def mantis_get_issues(mc, project_ids=None, per_page=100, **kwopts):
    if not project_ids:
        project_ids = []
        projects = soap_service(mc, 'mc_projects_get_user_accessible', **kwopts)
        for project in projects:
            project_ids.append(project.id)
    all_issues = []
    for project_id in project_ids:
        page = 1
        while True:
            issues = soap_service(mc, 'mc_project_get_issues', project_id=project_id, page_number=page, per_page=per_page, **kwopts)
            all_issues += issues
            if len(issues) < per_page:
                break
            page += 1
    return all_issues

def soap_service(client, method, **kwargs):
    '''This method exists to create a single code path to invoking SOAP services, that can be
    logged.
    '''
    safe_kwargs = dict(kwargs)
    if 'password' in safe_kwargs:
        safe_kwargs['password'] = '***'
    logging.debug('%s(%s)' % (method, ', '.join('%s=%s' % i for i in safe_kwargs.iteritems())))
    return getattr(client.service, method)(**kwargs)

def mantis_user_str(user):
    if not user:
        return 'None'
    r = [user.name]
    if user.real_name:
        r += [repr(user.real_name)]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def mantis_user_markdown(user):
    if not user:
        return 'None'
    r = ['**' + user.name + '**']
    d = mantis_user_details(user)
    if d:
        r += [d]
    return ' '.join(r)

def mantis_user_details(user):
    r = []
    if user.real_name:
        r += [user.real_name]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def github_dump_issue(issue):
    print 'number', '=', issue.number
    print 'title', '=', issue.title
    print 'state', '=', issue.state
    print 'milestone', '=', github_milestone_str(issue.milestone)
    print 'labels', '=', ', '.join(label.name for label in issue.labels)
    print 'created_at', '=', issue.created_at
    print 'updated_at', '=', issue.updated_at
    print 'user', '=', github_user_str(issue.user)
    print 'assignee', '=', github_user_str(issue.assignee)
    print 'repository', '=', issue.repository
    print 'pull_request', '=', issue.pull_request.html_url if issue.pull_request else 'None'
    print 'id', '=', issue.id
    print 'html_url', '=', issue.html_url
    print 'url', '=', issue.url
    print 'closed_at', '=', issue.closed_at
    print 'closed_by', '=', github_user_str(issue.closed_by)
    print 'body', '=', issue.body
    print 'comments', '=', issue.comments
    if issue.comments:
        for i, comment in enumerate(issue.get_comments()):
            print '-------------------- comment', i + 1, '--------------------'
            github_dump_issue_comment(comment)

def github_dump_issue_comment(comment):
    print 'user', '=', github_user_str(comment.user)
    print 'created_at', '=', comment.created_at
    print 'updated_at', '=', comment.updated_at
    print 'id', '=', comment.id
    print 'url', '=', comment.url
    print 'body', '=', comment.body

def github_user_str(user):
    if not user:
        return 'None'
    r = [user.login]
    if user.name:
        r += [repr(user.name)]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def github_milestone_str(milestone):
    return '%s (%s) %s' % (milestone.number, milestone.due_on, milestone.title) if milestone else 'None'

def map_user(config, gh, mantis_user):
    '''Convert a Mantis AccountData object into a GitHub NamedUser object.'''
    if mantis_user is None:
        return None
    ghname = config.user_map.get(mantis_user.name, None)
    return gh.get_user(ghname) if ghname else None

def resolve_user(config, github_users, mantis_account):
    github_reporter_login = config.user_map.get(mantis_account.name)
    gh, ref, tag = None, None, None
    if github_reporter_login is None:
        ref = mantis_user_markdown(mantis_account)
        tag = mantis_user_details(mantis_account)
    else:
        ref = '@' + github_reporter_login
        tag = ref
        github_reporter = github_users.get(github_reporter_login)
        if github_reporter and github_reporter.org is not None:
            gh = github_reporter
    logging.debug('resolved mantis user %r to %r %s' % (mantis_account.name, tag, '(auth)' if gh else '(no auth)'))
    return gh, ref, tag

def mantis_text_to_markdown(text):
    # Remove leading blank lines.
    text = re.sub(r'^( *\n)+', '', text)
    # If it looks like a stack trace or log file, then preformat it.  Otherwise, remove
    # unintended Markdown effects.
    if (    len(re.findall(r'\bat .*\(.*\.java:[0-9]+\)', text)) > 3
        or  len(re.findall(r'^ *(DEBUG|WARN|INFO|ERROR):', text, flags=re.MULTILINE)) > 3
        or  len(re.findall(r'^ *[EWIDV]/', text, flags=re.MULTILINE)) > 3
        ):
        text = '```' + text + '\n```'
    else:
        text = re.subn(r'^ {4,}', '   ', text, flags=re.MULTILINE)[0]
    return text

def parse_mantis_xml(f):
    '''This is left-over code from an early attempt to parse the XML exported by Mantis.
    '''
    import lxml.etree
    import lxml.objectify
    tree = lxml.objectify.parse(f)
    root = tree.getroot()
    for issue in root.iterchildren():
        if issue.status != 'closed':
            print issue.id, issue.summary

if __name__ == '__main__':
    main()
