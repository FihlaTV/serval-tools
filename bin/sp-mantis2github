#!/usr/bin/env python

# Serval Project Mantis-to-Git issue migration tool.
# Copyright 2012 Serval Project Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

# The following doc comment actually defines the command-line syntax, and
# drives its parsing, via the docopt module.

'''Usage:
    sp-mantis2github [options] mantis version
    sp-mantis2github [options] mantis wsdl
    sp-mantis2github [options] mantis list projects
    sp-mantis2github [options] mantis list project users [<project-id>]
    sp-mantis2github [options] mantis list enum status
    sp-mantis2github [options] mantis list enum resolutions
    sp-mantis2github [options] mantis list issue users
    sp-mantis2github [options] mantis list issues [<project-id>] [-C|--closed] [-O|--open]
    sp-mantis2github [options] mantis dump project <project-id>
    sp-mantis2github [options] mantis dump issue <issue-id>
    sp-mantis2github [options] mantis add note <issue-id> <text>
    sp-mantis2github [options] github register
    sp-mantis2github [options] github list users
    sp-mantis2github [options] github list repos
    sp-mantis2github [options] github list issues <repo-name>
    sp-mantis2github [options] github dump issue <repo-name> <issue-number>
    sp-mantis2github [options] github unset milestone <repo-name> <issue-number>
    sp-mantis2github [options] github unset assignee <repo-name> <issue-number>
    sp-mantis2github [options] github create issue <repo-name> <title> <body>
    sp-mantis2github [options] github delete issue <repo-name> <issue-number>
    sp-mantis2github [options] migrate <issue-id> <repo-name> [<github-issue-number>]
    sp-mantis2github [options] migrated [<mantis-issue-id>...]
    sp-mantis2github [options] relink <github-repo-name> [<github-issue-number>...]
    sp-mantis2github -h | --help
    sp-mantis2github --version
Options:
    -h --help               Show this message
    --version               Show version and exit
    -D --debug              Enable debug logging
    --mantis-debug          Enable debug logging of raw Mantis SOAP requests
    --github-debug          Enable debug logging of raw GitHub HTTP requests
    -n --dry-run            Do not write to GitHub, do queries only
    -t --testing            When migrating, do not modify the original Mantis issue; normally
                            a note is added to the issue linking to its GitHub successor, and
                            the Mantis issue is closed with "suspended" resolution
    -f --force              When migrating, continue even if the issue is already migrated
    -b --behalf             When migrating, create GitHub issue and comments on behalf of
                            original Mantis reporters; without this option will fail if the
                            Mantis issue or any comment is by a user who cannot be mapped to
                            an authorised GitHub user
    --config=PATH           Read config file [default: $HOME/.mantis2github]
    --mantis-url=URL        Connect to Mantis SOAP service at this URL (default taken from
                            $SERVAL_MANTIS_URL/api/soap/mantisconnect.php if set, or config file)
    --mantis-user=USER      Connect to Mantis with this user name (overrides config file)
    --mantis-password=PASS  Connect to Mantis with this password (overrides config file)
    --github-login=USER     Connect to GitHub with this user name (overrides config file)
    --github-password=PASS  Connect to GitHub with this password (overrides config file)
    --github-org=NAME       Use repositories in this GitHub organisation (overrides config file)
    -C --closed             When listing issues or users of issues, only include closed issues
    -O --open               When listing issues, only include open issues
    --close-github          When migrating, close GitHub issue after migration is done
    --no-close-mantis       When migrating, do not close Mantis issue after migration is done
    --no-comments           When migrating, do not delete and re-add comments (useful for updating
                            body description, labels, assignee, and milestone)
    --no-close-github       When deleting, do not close GitHub issue after marking it as DELETED

The config file is in INI format.  It contains user names and passwords in the clear so it is
ignored unless owned by the caller and permissions are at most 0600.
'''

myname = 'sp-mantis2github'
myversion = '0.99'
myurl = 'https://github.com/servalproject/serval-tools/blob/master/bin/' + myname

import sys
import traceback
import os
import os.path
import logging
import ConfigParser
import datetime
import urllib2
import re

def main():
    logging.basicConfig(level=logging.INFO)
    logging.getLogger('suds').setLevel(logging.CRITICAL)
    sys.path.append(os.path.join(serval_tools_root(), "python/docopt"))
    sys.path.append(os.path.join(serval_tools_root(), "python/PyGithub"))
    import docopt
    import github
    cx = Context()
    cx.opts = docopt.docopt(__doc__, version=myversion)
    #print cx.opts
    cx.config_path = os.path.expanduser(os.path.expandvars(cx.opts['--config']))
    cx.mantis.url = os.environ.get('SERVAL_MANTIS_URL')
    cx.read_config_file()
    if cx.opts['--debug']:
        cx.debug_enabled = True
    if cx.opts['--mantis-debug']:
        cx.mantis.debug_enabled = True
    if cx.opts['--github-debug']:
        cx.github.debug_enabled = True
    cx.dry_run = cx.opts['--dry-run']
    cx.testing = cx.opts['--testing']
    cx.close_github = cx.opts['--close-github']
    cx.no_close_github = cx.opts['--no-close-github']
    cx.no_comments = cx.opts['--no-comments']
    cx.no_close_mantis = cx.opts['--no-close-mantis']
    cx.force = cx.opts['--force']
    cx.behalf = cx.opts['--behalf']
    cx.mantis.url = cx.opts['--mantis-url'] or cx.mantis.url
    cx.mantis.user = cx.opts['--mantis-user'] or cx.mantis.user
    cx.mantis.password = cx.opts['--mantis-password'] or cx.mantis.password
    cx.mantis.include_open = cx.opts['--open']
    cx.mantis.include_closed = cx.opts['--closed']
    cx.github.login = cx.opts['--github-login'] or cx.github.login
    cx.github.password = cx.opts['--github-password'] or cx.github.password
    cx.github.default_org_name = cx.opts['--github-org'] or cx.github.default_org_name
    if cx.debug_enabled:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.getLogger('suds').setLevel(logging.INFO)
        logging.getLogger('github').setLevel(logging.INFO)
    if cx.mantis.debug_enabled:
        logging.getLogger('suds').setLevel(logging.DEBUG)
    if cx.github.debug_enabled:
        logging.getLogger('github').setLevel(logging.DEBUG)
    try:
        if cx.opts['mantis']:
            if cx.opts['wsdl']:
                print cx.mantis.client()
            elif cx.opts['version']:
                print cx.mantis.service('mc_version')
            elif cx.opts['list'] and cx.opts['projects']:
                projects = cx.mantis.service_cred('mc_projects_get_user_accessible')
                projects.sort(key=lambda p: p.id)
                for project in projects:
                    print '%-5s %-15s %-15s %-40s' % (project.id, project.status.name, project.view_state.name, project.name)
            elif cx.opts['dump'] and cx.opts['project']:
                try:
                    project_id = int(cx.opts['<project-id>'])
                except ValueError:
                    fatal('invalid <project-id>')
                projects = cx.mantis.service_cred('mc_projects_get_user_accessible')
                for project in projects:
                    if project.id == project_id:
                        print project
            elif cx.opts['dump'] and cx.opts['issue']:
                try:
                    mantis_issue_id = int(cx.opts['<issue-id>'])
                except ValueError:
                    fatal('invalid <issue-id>')
                print cx.mantis.get_issue(mantis_issue_id)
            elif cx.opts['list'] and cx.opts['project'] and cx.opts['users']:
                project_ids = []
                if cx.opts['<project-id>']:
                    try:
                        project_ids.append(int(cx.opts['<project-id>']))
                    except ValueError:
                        fatal('invalid <project-id>')
                all_users = cx.mantis.get_users(project_ids)
                for user in all_users.itervalues():
                    values = (getattr(user, 'name', ''), getattr(user, 'real_name', ''), getattr(user, 'email', ''))
                    if values != ('', '', ''):
                        print '%-20s %-30s %s' % values
            elif cx.opts['list'] and cx.opts['issue'] and cx.opts['users']:
                all_issues = cx.mantis.get_issues().values()
                users = {}
                for issue in all_issues:
                    try:
                        users[issue.reporter.id] = issue.reporter
                    except AttributeError:
                        pass
                    try:
                        users[issue.handler.id] = issue.handler
                    except AttributeError:
                        pass
                users = users.values()
                users.sort(key=lambda u: (getattr(u, 'name', ''), getattr(u, 'real_name', '')))
                for user in users:
                    values = (getattr(user, 'name', ''), getattr(user, 'real_name', ''), getattr(user, 'email', ''))
                    if values != ('', '', ''):
                        print '%-20s %-30s %s' % values
            elif cx.opts['list'] and cx.opts['enum'] and cx.opts['status']:
                for elt in cx.mantis.get_enum_status():
                    print elt
            elif cx.opts['list'] and cx.opts['enum'] and cx.opts['resolutions']:
                for elt in cx.mantis.get_enum_resolutions():
                    print elt
            elif cx.opts['list'] and cx.opts['issues']:
                project_ids = []
                if cx.opts['<project-id>']:
                    try:
                        project_ids.append(int(cx.opts['<project-id>']))
                    except ValueError:
                        fatal('invalid <project-id>')
                all_issues = cx.mantis.get_issues(project_ids).values()
                all_issues.sort(key=lambda p: p.id)
                for issue in all_issues:
                    flags = [' '] * 2
                    if getattr(issue, 'attachments', None):
                        flags[0] = 'A'
                    if getattr(issue, 'relationships', None):
                        flags[1] = 'R'
                    print '%-5s %-10s %-10s %s %s' % (issue.id, issue.status.name, issue.resolution.name, ''.join(flags), issue.summary)
            elif cx.opts['add'] and cx.opts['note']:
                try:
                    mantis_issue_id = int(cx.opts['<issue-id>'])
                except ValueError:
                    fatal('invalid <issue-id>')
                text = cx.opts['<text>']
                cx.mantis.debug('add_note(%r, %r)', mantis_issue_id, text)
                if not cx.dry_run:
                    cx.mantis.add_note(mantis_issue_id, text)
        elif cx.opts['github']:
            if cx.opts['register']:
                ghc = cx.github.main()
                ghc.open()
                ghc.debug('get_user()')
                ghuser = ghc.open().get_user()
                scopes = ['public_repo']
                note = myname + ' version ' + myversion
                ghc.debug('create_authorization(scopes=%r, note=%r)', scopes, note)
                if not cx.dry_run:
                    auth = ghuser.create_authorization(scopes=scopes, note=note)
                    print auth.token
            elif cx.opts['list'] and cx.opts['users']:
                org = cx.github.default_connection().org()
                org.open()
                org.debug('get_members()')
                users = list(org.open().get_members())
                users.sort(key=lambda u: (u.login, u.name))
                for user in users:
                    print '%-20s %-30s %s' % (user.login, user.name or '', user.email or '')
            elif cx.opts['list'] and cx.opts['repos']:
                org = cx.github.default_connection().org()
                org.open()
                org.debug('get_repos()')
                repos = org.open().get_repos()
                for repo in repos:
                    print repo.name
            elif cx.opts['list'] and cx.opts['issues']:
                repo_name = cx.opts['<repo-name>']
                repo = cx.github.default_connection().org().repo(repo_name)
                state = 'open' if cx.opts['--open'] else None
                if cx.opts['--closed']:
                    state = 'closed' if state is None else None
                issues = list(repo.get_issues(state=state))
                issues.sort(key=lambda p: p.number)
                for issue in issues:
                    print '%-5s %-10s %s' % (issue.number, issue.open().state, issue.open().title)
            elif cx.opts['dump'] and cx.opts['issue']:
                repo_name = cx.opts['<repo-name>']
                try:
                    issue_number = int(cx.opts['<issue-number>'])
                except ValueError:
                    fatal('invalid <issue-number>')
                issue = cx.github.default_connection().org().repo(repo_name).issue(issue_number)
                issue.open()
                issue.dump()
            elif cx.opts['create'] and cx.opts['issue']:
                repo_name = cx.opts['<repo-name>']
                title = cx.opts['<title>']
                body = cx.opts['<body>']
                repo = cx.github.default_connection().org().repo(repo_name)
                repo.open()
                labels = []
                issue = repo.new_issue()
                issue.create(dry_run=cx.dry_run, title=title, body=body, labels=labels)
                issue.dump()
            elif cx.opts['delete'] and cx.opts['issue']:
                repo_name = cx.opts['<repo-name>']
                try:
                    issue_number = int(cx.opts['<issue-number>'])
                except ValueError:
                    fatal('invalid <issue-number>')
                issue = cx.github.default_connection().org().repo(repo_name).issue(issue_number)
                issue.delete(state= None if cx.no_close_github else 'closed')
            elif cx.opts['unset']:
                repo_name = cx.opts['<repo-name>']
                try:
                    issue_number = int(cx.opts['<issue-number>'])
                except ValueError:
                    fatal('invalid <issue-number>')
                issue = cx.github.default_connection().org().repo(repo_name).get_issue(issue_number)
                issue.open()
                if cx.opts['milestone']:
                    issue.edit(milestone=None, dry_run=cx.dry_run)
                if cx.opts['assignee']:
                    issue.edit(assignee=None, dry_run=cx.dry_run)
        elif cx.opts['migrate']:
            try:
                mantis_issue_id = int(cx.opts['<issue-id>'])
            except ValueError:
                fatal('invalid <issue-id>')
            repo_name = cx.opts['<repo-name>']
            github_issue_number = None
            if cx.opts['<github-issue-number>']:
                try:
                    github_issue_number = int(cx.opts['<github-issue-number>'])
                except ValueError:
                    fatal('invalid <github-issue-number>')
            # Fetch the original Mantis issue.
            mantis_issue = cx.mantis.get_issue(mantis_issue_id)
            status = getattr(getattr(mantis_issue, 'status', None), 'name', None)
            resolution = getattr(getattr(mantis_issue, 'resolution', None), 'name', None)
            mantis_issue_closed = status in ('closed', 'resolved')
            # Check if it is already migrated.
            migrated_github_refs = list(cx.mantis.migrated_github_references(mantis_issue))
            # Resolve the Mantis reporter to a GitHub user.
            authentic_creator_ghc, creator_ref = cx.resolve_user(mantis_issue.reporter)
            if authentic_creator_ghc is None:
                logging.warn('Mantis issue %s was reported by %s, no equivalent authorised GitHub user' % (mantis_issue_id, mantis_issue.reporter.name,))
                if not cx.behalf:
                    fatal('use --behalf option to migrate issue as GitHub user %s' % (cx.github.default_connection().login,))
                creator_ghc = cx.github.default_connection()
            else:
                creator_ghc = authentic_creator_ghc
            repo = creator_ghc.org().repo(repo_name)
            repo.open()
            # Fetch all GitHub issues to which this Mantis issue has already been migrated.
            migrated_github_issues = []
            for ref in migrated_github_refs:
                issue = creator_ghc.issue(ref)
                issue.open()
                migrated_github_issues.append(issue)
                logging.info('Mantis issue %s is marked as migrated to GitHub %s%s' % (
                        mantis_issue_id, issue.ref, ' (deleted)' if issue.is_deleted() else ''
                    ))
            # Work out whether to create a new GitHub issue or overwrite an existing one.
            overwrite_issue = None
            delete_issue = None
            if github_issue_number:
                # The user specified an existing target GitHub issue.  If it appears to be DELETED
                # or a migration of the original Mantis issue (two-way check: the Mantis issue has a
                # note that it has been migrated to this GitHub issue, and the GitHub issue's first
                # comment contains a link back to the Mantis issue) then overwrite it without
                # further ado.  Otherwise, insist that --force be given to continue.
                target_issue = repo.issue(github_issue_number)
                target_issue.open()
                if target_issue.is_deleted():
                    logging.info('overwriting DELETED GitHub %s' % (target_issue.ref,))
                    overwrite_issue = target_issue
                elif target_issue in migrated_github_issues and target_issue.is_migrated_from(cx.mantis, mantis_issue_id):
                    logging.info('overwriting previously migrated GitHub %s' % (target_issue.ref,))
                    if not cx.no_comments:
                        delete_issue = target_issue
                    overwrite_issue = target_issue
                else:
                    logging.warn('Mantis issue %s is not already migrated to GitHub %s' % (mantis_issue_id, target_issue.ref))
                    if not cx.force:
                        fatal('use --force to overwrite existing GitHub issue')
                    logging.info('overwriting GitHub %s' % (issue.ref,))
                    if not cx.no_comments:
                        delete_issue = target_issue
                    overwrite_issue = target_issue
            else:
                # If the Mantis issue was not already migrated, then create a new GitHub issue.
                #
                # If the Mantis issue is already migrated to a single issue in the target repo and
                # that issue is now DELETED or the two-way check is consistent, then overwrite that
                # issue without further ado (unless the original creator is wrong).  If the two-way
                # check fails, then only proceed if --force was given.
                #
                # If the Mantis issue is already migrated to more than one issue in the target repo,
                # then refuse to continue.  The user must explicitly specify which one to overwrite,
                # and may delete the others manually.
                migrated_github_issues_same_repo = [issue for issue in migrated_github_issues if issue in repo]
                migrated_github_issues_same_repo_not_deleted = [issue for issue in migrated_github_issues_same_repo if not issue.is_deleted()]
                if len(migrated_github_issues_same_repo) == 0:
                    logging.info('creating new GitHub issue')
                elif len(migrated_github_issues_same_repo_not_deleted) == 1:
                    issue = migrated_github_issues_same_repo_not_deleted[0]
                    if issue.is_migrated_from(cx.mantis, mantis_issue_id):
                        logging.info('overwriting previously migrated GitHub %s' % (issue.ref,))
                        if not cx.no_comments:
                            delete_issue = issue
                        overwrite_issue = issue
                    else:
                        logging.warn('Mantis issue %s appears migrated to GitHub %s, which does not agree' % (mantis_issue_id, issue.ref))
                        if not cx.force:
                            fatal('use --force to create a new GitHub issue')
                        logging.info('overwriting GitHub %s' % (issue.ref,))
                elif len(migrated_github_issues_same_repo) == 1:
                    issue = migrated_github_issues_same_repo[0]
                    logging.info('overwriting DELETED GitHub %s' % (issue.ref,))
                    overwrite_issue = issue
                else:
                    logging.warn('Mantis issue %s appears migrated to GitHub issues:\n   %s' % (mantis_issue_id,
                            '\n   '.join(str(issue.ref) + (' (deleted)' if issue.is_deleted() else '')
                                            for issue in migrated_github_issues_same_repo),
                        ))
                    fatal('give <github-issue-number> to overwrite an existing issue')
                # If we found an existing issue to overwrite (rather than the user explicitly
                # specifying one) and it was created by the wrong GitHub user and we have the
                # correct authorised user now, then delete the old issue and create a new issue.
                if (    overwrite_issue
                    and authentic_creator_ghc
                    and overwrite_issue.open().user.id != authentic_creator_ghc.open().get_user().id):
                    logging.warn('deleting GitHub issue %s (user %s) and creating new GitHub issue as user %s' % (
                            overwrite_issue.ref, overwrite_issue.open().user.login, authentic_creator_ghc.login))
                    delete_issue = overwrite_issue
                    overwrite_issue = None
            # Keep a reference to the target GitHub issue, if one is being overwritten, otherwise
            # to the target GitHub repository.  This is used as a context for forming GitHub
            # Flavoured Markdown issue references and for translating Mantis issue links into
            # GitHub issue markdown references.
            target_issue_ref = overwrite_issue.ref if overwrite_issue else repo.ref
            # If the --testing option was given, or the Mantis issue is already marked as migrated to
            # the target GitHubIssue and is already closed, then no need to modify the Mantis issue
            # after migrating.  Otherwise, if the Mantis issue is closed, it cannot be modified.
            if not cx.testing:
                mantis_actions = []
                if overwrite_issue is None or overwrite_issue.ref not in migrated_github_refs:
                    mantis_actions += ['add a note to mark it as migrated']
                if not cx.no_close_mantis and (status != 'closed' or resolution != 'suspended'):
                    mantis_actions += ['close it as suspended']
                if mantis_actions and mantis_issue_closed:
                    logging.warn('Mantis issue %r is %s (%s), so cannot %s' % (mantis_issue_id, status, resolution, ' and '.join(mantis_actions)))
                    fatal('use --testing to leave the Mantis issue unaltered, or reopen the Mantis issue and try again')
            # Discover things about the destination GitHub repo.
            repo.debug('get_milestones(state="open")')
            repo_milestones_open = list(repo.open().get_milestones(state='open'))
            repo.debug('   got %r', [milestone.title for milestone in repo_milestones_open])
            repo.debug('get_milestones(state="closed")')
            repo_milestones_closed = list(repo.open().get_milestones(state='closed'))
            repo.debug('   got %r', [milestone.title for milestone in repo_milestones_closed])
            repo_milestones = repo_milestones_open + repo_milestones_closed
            repo.debug('get_labels()')
            repo_labels = dict((label.name, label) for label in repo.open().get_labels())
            repo.debug('   got %r', list(repo_labels))
            # Create GitHub "mantis" label unless it already exists, in which case make sure it is
            # the right colour.
            label_name = 'mantis'
            label_colour = '034c31' # Mantis logo text colour
            label = repo_labels.get(label_name)
            if label is None:
                repo.debug('create_label(name=%r, color=%r)', label_name, label_colour)
                if not cx.dry_run:
                    label = repo.open().create_label(name=label_name, color=label_colour)
                    if not label:
                        fatal('cannot create label %r' % (label_name,))
            elif label.color.lower() != label_colour:
                repo.debug('label=%r edit(name=%r, color=%r)', label_name, label_name, label_colour)
                if not cx.dry_run:
                    label.edit(name=label_name, color=label_colour)
            # Start assembling the body, comments and labels of the GitHub issue.
            labels = [label]
            body = []
            comments = [] # [(datetime, GithubInterface, str|closemark)]
            closemark = object()
            to_relink = set()
            if not authentic_creator_ghc or (overwrite_issue and overwrite_issue.open().user.id != authentic_creator_ghc.open().get_user().id):
                body += [creator_ref, ' reported:\n\n']
            body += [cx.text_to_markdown(mantis_issue.description, target_issue_ref, linkset=to_relink)]
            body += ['\n']
            if hasattr(mantis_issue, 'severity') and mantis_issue.severity:
                body += ['\nMantis severity: **', mantis_issue.severity.name, '**']
            if hasattr(mantis_issue, 'priority') and mantis_issue.priority:
                body += ['\nMantis priority: **', mantis_issue.priority.name, '**']
            if hasattr(mantis_issue, 'project') and mantis_issue.project:
                body += ['\nMantis project: **', mantis_issue.project.name, '**']
            if hasattr(mantis_issue, 'version') and mantis_issue.version:
                body += ['\nProduct version: **', mantis_issue.version, '**']
            if hasattr(mantis_issue, 'target_version') and mantis_issue.target_version:
                body += ['\nTarget version: **', mantis_issue.target_version, '**']
            if hasattr(mantis_issue, 'fixed_in_version') and mantis_issue.fixed_in_version:
                body += ['\nFixed in version: **', mantis_issue.fixed_in_version, '**']
            # Map the Mantis assignee to a GitHub user.
            github_assignee = cx.map_user(getattr(mantis_issue, 'handler', None))
            # Map target version or fixed-in version to GitHub milestone.
            target_version = None
            if hasattr(mantis_issue, 'fixed_in_version') and mantis_issue.fixed_in_version:
                target_version = mantis_issue.fixed_in_version
            elif hasattr(mantis_issue, 'target_version') and mantis_issue.target_version:
                target_version = mantis_issue.target_version
            github_milestone = None
            if target_version:
                target_version = target_version.strip()
                for milestone in repo_milestones:
                    for word in target_version.split():
                        if word not in milestone.title:
                            break
                    else:
                        github_milestone = milestone
                        break
            # Translate Mantis resolution to GitHub label of the same name if it exists, otherwise
            # label as 'duplicate', 'invalid' or 'wontfix' accordingly.
            if resolution in repo_labels: # includes 'duplicate'
                labels += [repo_labels[resolution]]
            elif resolution == 'unable to reproduce':
                if 'invalid' in repo_labels:
                    labels += [repo_labels['invalid']]
                elif 'wontfix' in repo_labels:
                    labels += [repo_labels['wontfix']]
            elif resolution in ('not fixable', "won't fix"):
                if 'wontfix' in repo_labels:
                    labels += [repo_labels['wontfix']]
            # Translate Mantis severity level to GitHub label of the same name if it exists,
            # otherwise label 'feature' and 'tweak' as an enhancement, and all others as bugs.
            if hasattr(mantis_issue, 'severity') and mantis_issue.severity:
                if mantis_issue.severity.name in repo_labels:
                    labels += [repo_labels[mantis_issue.severity.name]]
                elif mantis_issue.severity.name in ('feature', 'tweak'):
                    if 'enhancement' in repo_labels:
                        labels += [repo_labels['enhancement']]
                else:
                    if 'bug' in repo_labels:
                        labels += [repo_labels['bug']]
            # Translate Mantis tags into GitHub tags of the same name, if they exist.
            if hasattr(mantis_issue, 'tags') and mantis_issue.tags:
                body += ['\nMantis tags: ']
                body += ('**%s**' % tag.name for tag in mantis_issue.tags)
                for tag in mantis_issue.tags:
                    if tag.name in repo_labels:
                        labels += [repo_labels[tag.name]]
            if hasattr(mantis_issue, 'relationships') and mantis_issue.relationships:
                for related in mantis_issue.relationships:
                    if related.type.name == 'related to':
                        related_issue_id = related.target_id
                        related_mantis_issue = cx.mantis.get_issue(related_issue_id)
                        body += ['\nRelated to:']
                        for md in cx.mantis_issue_link_markdown(related_issue_id, target_issue_ref, linkset=to_relink):
                            body += [' **%s**' % md]
                        related_title = unicode(related_mantis_issue.summary)
                        if related_title:
                            body += [' **', cx.escape_markdown(related_title), '**']
            body += ['\nCan reproduce: **', mantis_issue.reproducibility.name, '**']
            if hasattr(mantis_issue, 'steps_to_reproduce') and mantis_issue.steps_to_reproduce:
                body += ['\nTo reproduce:\n\n', cx.text_to_markdown(mantis_issue.steps_to_reproduce, target_issue_ref, linkset=to_relink)]
            if hasattr(mantis_issue, 'additional_information') and mantis_issue.additional_information:
                body += ['\n\n' + cx.text_to_markdown(mantis_issue.additional_information, target_issue_ref, linkset=to_relink)]
            title = unicode(mantis_issue.summary)
            body = u''.join(body)
            # This must be the first comment to make it easy to later detect and cross-reference Mantis
            # issues to GitHub issues.
            comments += [(mantis_issue.date_submitted, creator_ghc,
                    GithubIssue.MIGRATION_TEXT + '**' + cx.mantis.issue_link_markdown(mantis_issue.id) + '**' +
                    (' by ' + creator_ref if not authentic_creator_ghc else '') +
                    ' at ' + mantis_issue.date_submitted.ctime() + '.'
                )]
            # Convert Mantis attachments and notes into GitHub comments, and sort them in
            # chronological order.  Check whether the Mantis issue is already noted as migrated to
            # this repo, and if so, to which GitHub issue.
            if hasattr(mantis_issue, 'attachments') and mantis_issue.attachments:
                all_users = cx.mantis.get_users([mantis_issue.project.id])
                for attachment in mantis_issue.attachments:
                    attacher_user_id = getattr(attachment, 'user_id', None)
                    attacher_ghc, attacher_ref, attacher_tag = None, None, None
                    if attacher_user_id in all_users:
                        attacher_ghc, attacher_ref = cx.resolve_user(all_users[attacher_user_id])
                    comment_body = []
                    comment_body += ['At ', attachment.date_submitted.ctime()]
                    if not attacher_ghc:
                        logging.warn('Mantis attachment %s has no equivalent authorised GitHub user' % (attachment.filename or '<untitled>',))
                        if not cx.behalf:
                            fatal('use --behalf option to migrate attachments as GitHub user %s' % (cx.github.default_connection().login,))
                        attacher_ghc = cx.github.default_connection()
                        comment_body += [' ', attacher_ref]
                    comment_body += [' attached **[', attachment.filename or 'untitled', '](', attachment.download_url, ')**']
                    if getattr(attachment, 'size', None):
                        comment_body += [', ', str(attachment.size), ' bytes']
                    if getattr(attachment, 'content_type', None):
                        comment_body += [', *', attachment.content_type, '*']
                    comment_body += ['.']
                    comments.append((attachment.date_submitted, attacher_ghc, ''.join(comment_body)))
            if hasattr(mantis_issue, 'notes') and mantis_issue.notes:
                for note in mantis_issue.notes:
                    note_text = note.text.lstrip() if hasattr(note, 'text') and note.text else ''
                    time_tracking = note.time_tracking if hasattr(note, 'time_tracking') else None
                    if (note_text or time_tracking) and cx.mantis.migrated_github_reference(text=note_text) != target_issue_ref:
                        noter_ghc, noter_ref = cx.resolve_user(note.reporter)
                        comment_body = []
                        comment_body += ['At ', note.date_submitted.ctime()]
                        if not noter_ghc:
                            logging.warn('Mantis note reported by %s has no equivalent authorised GitHub user' % (note.reporter.name,))
                            if not cx.behalf:
                                fatal('use --behalf option to migrate notes as GitHub user %s' % (cx.github.default_connection().login,))
                            noter_ghc = cx.github.default_connection()
                            comment_body += [' ', noter_ref, ' commented']
                        comment_body += [':']
                        if time_tracking:
                            hours = note.time_tracking / 60
                            minutes = note.time_tracking % 60
                            comment_body += ['\n\nTime spent: **%u:%02u**' % (hours, minutes)]
                        if note_text:
                            comment_body += ['\n\n', cx.text_to_markdown(note_text, target_issue_ref, linkset=to_relink)]
                        comments.append((note.date_submitted, noter_ghc, ''.join(comment_body)))
            # If the Mantis issue is closed, then close the GitHub issue also, with an explanatory
            # comment.
            if mantis_issue_closed:
                comments.append((mantis_issue.last_updated, creator_ghc,
                        'At ' + mantis_issue.last_updated.ctime() +
                        ' Mantis issue status **' + status + '**' +
                        (', resolution **' + resolution + '**' if resolution else '') +
                        '.'
                    ))
                comments.append((mantis_issue.last_updated, creator_ghc, closemark))
            # Add a final comment about the migration.
            migration_body = ['Issue migrated from Mantis to GitHub']
            if not mantis_issue_closed:
                migration_body += [' with Mantis']
                if status:
                    migration_body += [' status **', status, '**']
                if status and resolution:
                    migration_body += [' and']
                if resolution:
                    migration_body += [' resolution **', resolution, '**']
            now = datetime.datetime.now()
            migration_body += [
                    ' at ', now.ctime(),
                    ' using [', myname, '](', myurl, ') version ', myversion
                ]
            comments.append((now, cx.github.default_connection(), ''.join(migration_body)))
            # If the user wants the GitHub issue closed and it wasn't closed because of a closed
            # Mantis issue then close it now.
            if not mantis_issue_closed and cx.close_github:
                comments.append((mantis_issue.last_updated, creator_ghc, closemark))
            # Having assembled the new GitHub issue, now perform modifications to GitHub.  Start
            # by deleting any issue that is being superceded or overwritten.
            issue = None
            if delete_issue:
                delete_issue.open()
                # If we are not going to overwrite this issue, then close it as well as deleting it.
                delete_issue.delete(state= 'closed' if overwrite_issue != delete_issue else None)
            # If a new issue is being created, create it now, otherwise overwrite it.
            if overwrite_issue is None:
                issue = repo.new_issue()
                issue.create(title=title, body=body, labels=labels, dry_run=cx.dry_run)
            else:
                issue = overwrite_issue
                issue.edit(state='open', title=title, body=body, labels=labels, dry_run=cx.dry_run)
            # Set the GitHub milestone.
            if github_milestone is not None:
                issue.edit(milestone=github_milestone, dry_run=cx.dry_run)
                if not cx.dry_run and getattr(issue.open().milestone, 'id', None) != github_milestone.id:
                    logging.warn('cannot set issue to milestone %r' % (github_milestone.title,))
            # Set the GitHub assignee.
            if github_assignee is not None:
                issue.edit(assignee=github_assignee, dry_run=cx.dry_run)
                if not cx.dry_run and getattr(issue.open().assignee, 'login', None) != github_assignee.login:
                    logging.warn('cannot assign issue to %r -- adding GitHub comment instead' % (github_assignee.login,))
                    comments.insert(1, (mantis_issue.date_submitted, cx.github.default_connection(),
                            'Assigned to Mantis user ' + cx.mantis.user_markdown(mantis_issue.handler) + '.'
                        ))
            # Set the GitHub comments.
            if not cx.no_comments:
                comments.sort(key=lambda c: c[0])
                for commenter_time, commenter_ghc, comment_body in comments:
                    commenter_issue = commenter_ghc.org().repo(repo_name).issue(issue.number)
                    if comment_body is closemark:
                        commenter_issue.edit(state='closed', dry_run=cx.dry_run)
                        if not cx.dry_run and commenter_issue.open().state != 'closed':
                            logging.warn('cannot close issue #%r' % (commenter_issue.number,))
                    else:
                        commenter_issue.debug('create_comment(%r)', comment_body)
                        if not cx.dry_run:
                            commenter_issue.open().create_comment(comment_body)
            # If this issue replaces an existing migration of the same Mantis issue, then put a
            # reference into the deleted issue to point to this one, so that old GitHub
            # references to the deleted one can still be followed to the new one.  This is done
            # _after_ all the migrated comments are added, because it creates a comment in the
            # GitHub issue that should not be the first comment.
            if delete_issue and issue != delete_issue:
                body = 'Superceded by %s' % issue.ref.markdown(delete_issue.ref)
                delete_issue.edit(body=body, dry_run=cx.dry_run)
            # Mark the Mantis issue as migrated: add a note linking to the GitHub issue, and close
            # the Mantis issue with resolution "suspended".
            if not cx.testing:
                if overwrite_issue is None or overwrite_issue.ref not in migrated_github_refs:
                    text = MantisInterface.MIGRATION_TEXT + getattr(issue.open(), 'html_url', 'None')
                    cx.mantis.debug('add_note(%r, %r)', mantis_issue_id, text)
                    if not cx.dry_run:
                        cx.mantis.add_note(mantis_issue_id, text)
                if not cx.no_close_mantis and (status != 'closed' or resolution != 'suspended'):
                    cx.mantis.debug('update_status(%r, status=%r, resolution=%r)', mantis_issue_id, 'closed', 'suspended')
                    if not cx.dry_run:
                        cx.mantis.update_status(mantis_issue_id, 'closed', 'suspended')
            # Relink all issues that are likely to contain references to the one just migrated.
            cx.add_mantis_github_issue_ref(mantis_issue_id, issue.ref)
            cx.relink(to_relink, repo.ref)
        elif cx.opts['migrated']:
            try:
                mantis_issue_ids = map(int, cx.opts['<mantis-issue-id>'])
            except ValueError:
                fatal('invalid <mantis-issue-id>')
            if mantis_issue_ids:
                mantis_issues = {}
                for mantis_issue_id in mantis_issue_ids:
                    mantis_issues[mantis_issue_id] = cx.mantis.get_issue(mantis_issue_id)
            else:
                mantis_issues = cx.mantis.get_issues()
            for mantis_issue_id, mantis_issue in mantis_issues.iteritems():
                refs = []
                for ref in cx.mantis.migrated_github_references(mantis_issue):
                    github_issue = cx.github.main().issue(ref)
                    if not github_issue.is_deleted() and github_issue.is_migrated_from(cx.mantis, mantis_issue_id):
                        refs.append(ref)
                if refs:
                    print '%u: %s' % (mantis_issue_id, ' '.join(map(str, refs)))
        elif cx.opts['relink']:
            repo_name = cx.opts['<github-repo-name>']
            try:
                issue_numbers = map(int, cx.opts['<github-issue-number>'])
            except ValueError:
                fatal('invalid <github-issue-number>')
            repo = cx.github.default_connection().org().repo(repo_name)
            if issue_numbers:
                issues = [repo.issue(i) for i in issue_numbers]
            else:
                state = 'open' if cx.opts['--open'] else None
                if cx.opts['--closed']:
                    state = 'closed' if state is None else None
                issues = list(repo.get_issues(state=state))
            cx.relink(issues, repo.ref)
    except IOError, e:
        if cx.debug:
            traceback.print_exc()
        fatal('%s: %s' % (cx.mantis.url or '<Unknown URL>', e))
    except github.GithubException, e:
        if cx.debug:
            traceback.print_exc()
        fatal(u'GitHub error: %s' % (e,))

def fatal(message):
    logging.critical(message)
    sys.exit(1)

def serval_tools_root():
    return os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))

class DebuggableObject(object):

    def debug(self, msg, *args, **kwargs):
        tag = self.debugtag()
        if tag:
            logging.debug('%s ' + msg, tag, *args, **kwargs)
        else:
            logging.debug(msg, *args, **kwargs)

    def debugtag(self):
        return ''

class MantisInterface(DebuggableObject):

    debug_enabled = False
    url = None
    user = None
    password = None
    include_open = False
    include_closed = False
    _client = None

    _enum = None
    _projects = None
    _open_issues = None
    _closed_issues = None
    _issue_map = None

    def debugtag(self):
        return 'Mantis'

    def read_config(self, cp):
        try:
            self.url = cp.get('mantis', 'url', False, os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.user = cp.get('mantis', 'user', False, os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.password = cp.get('mantis', 'password', False, os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass

    def url_base(self):
        if not self.url:
            fatal("missing Mantis URL")
        try:
            return self.url[:self.url.index('/api/')]
        except ValueError:
            return self.url

    def url_soap(self):
        return self.url_base() + '/api/soap/mantisconnect.php?wsdl'

    def url_issue(self, issue_id):
        return self.url_base() + '/view.php?id=%s' % issue_id

    def issue_link_markdown(self, mantis_issue_id):
        return '[mantis:' + '%07u' % mantis_issue_id + '](' + self.url_issue(mantis_issue_id) + ')'

    def extract_referred_mantis_issue_ids(self, text):
        r'''Return an iterator over the IDs of all Mantis issues that are referred in the given text
        using Mantis issue reference notation #N.
        '''
        for match in re.finditer(r'#(\d+)', text):
            yield int(match.group(1))

    def extract_linked_mantis_issue_ids(self, text):
        r'''Return an iterator over the IDs of all Mantis issues that are linked in the given text
        using full Mantis URLs.
        '''
        url_base = self.url_issue('')
        start = 0
        i = text.find(url_base, start)
        while i != -1:
            start = i + len(url_base)
            m = re.match('\d+\b', text[start:])
            if m:
                mantis_issue_id = int(m.group(0))
                yield mantis_issue_id
                start = + len(m.group(0))
            i = text.find(url_base, start)

    def rewrite_markdown_links(self, text, issue_linker):
        r'''In a supplied markdown text, rewrite links as created by self.issue_link_markdown() into
        other links whose markdown text is generated by passing the Mantis issue number to the
        supplied issue_linker() function.
        '''
        def rewrite(match):
            mantis_issue_id = int(match.group(1))
            return issue_linker(mantis_issue_id) if match.group(2) == self.url_issue(mantis_issue_id) else match.group(0)
        return re.subn(r'\[mantis:(\d{7})\]\(([^)]*)\)', rewrite, text)[0]

    def client(self):
        if not self._client:
            import suds
            url = self.url_soap()
            self.debug('create SOAP client, url=%r', url)
            self._client = suds.client.Client(url)
        return self._client

    def user_markdown(self, user):
        if not user:
            return 'None'
        mantis_user_url = self.url_base() + '/view_user_page.php?id=' + str(user.id)
        # Do not include the user's real name or email here, even though it is available via SOAP,
        # because we do not want to put people's email addresses in the clear on GitHub to be harvested
        # by spammers.
        return '**[' + user.name + '](' + mantis_user_url + ')**'

    def service(self, method, exception_fatal=True, **kwargs):
        '''This method exists to create a single code path to invoking SOAP services, that can be
        logged.
        '''
        safe_kwargs = dict(kwargs)
        if 'password' in safe_kwargs:
            safe_kwargs['password'] = '***'
        import suds
        try:
            client = self.client()
            self.debug('%s(%s)', method, ', '.join('%s=%s' % i for i in safe_kwargs.iteritems()))
            return getattr(client.service, method)(**kwargs)
        except suds.WebFault, e:
            if self.debug:
                print >>sys.stderr, '%s(%s)' % (method, ', '.join('%s=%r' % i for i in kwargs.iteritems()))
                traceback.print_exc()
            if not exception_fatal:
                raise
            fatal(e)

    def service_cred(self, method, **kwargs):
        _kwargs = dict(self.credentials())
        _kwargs.update(kwargs)
        return self.service(method, **_kwargs)

    def credentials(self):
        if self.user is None:
            fatal("missing Mantis user name")
        if self.password is None:
            fatal("missing Mantis password")
        return {'username': self.user, 'password': self.password}

    def get_enum(self, enum, name=None, **kwopts):
        if self._enum is None:
            self._enum = {}
        if enum not in self._enum:
            self._enum[enum] = {}
            for elt in self.service_cred('mc_enum_' + enum):
                self._enum[enum][elt.name] = elt
        if name is None:
            return self._enum[enum].values()
        if name not in self._enum[enum]:
            fatal('no name %r in Mantis %r enum' % (name, enum))
        return self._enum[enum][name]

    def get_enum_status(self, name=None, **kwopts):
        return self.get_enum('status', name, **kwopts)

    def get_enum_resolutions(self, name=None, **kwopts):
        return self.get_enum('resolutions', name, **kwopts)

    def get_users(self, project_ids=None, **kwopts):
        if not project_ids:
            project_ids = []
            projects = self.service_cred('mc_projects_get_user_accessible', **kwopts)
            for project in projects:
                project_ids.append(project.id)
        all_users = {}
        for project_id in project_ids:
            users = self.service_cred('mc_project_get_users', project_id=project_id, access=1, **kwopts)
            for user in users:
                all_users[user.id] = user
        return all_users

    def get_projects(self, **kwopts):
        if self._projects is None:
            self._projects = {}
            projects = self.service_cred('mc_projects_get_user_accessible', **kwopts)
            for project in projects:
                self._projects[project.id] = project
        return self._projects

    def get_issue(self, issue_id):
        for idict in self._open_issues, self._closed_issues:
            if idict and issue_id in idict:
                return idict[issue_id]
        issue = self.service_cred('mc_issue_get', issue_id=issue_id)
        if issue.status.name in ('resolved', 'closed'):
            if self._closed_issues is None:
                self._closed_issues = {}
            self._closed_issues[issue_id] = issue
        else:
            if self._open_issues is None:
                self._open_issues = {}
            self._open_issues[issue_id] = issue
        return issue

    def get_open_issues(self, project_ids=None, per_page=100, **kwopts):
        if self._open_issues is None:
            self._open_issues = {}
            if not project_ids:
                project_ids = self.get_projects(**kwopts).keys()
            for project_id in project_ids:
                if project_id not in self._open_issues:
                    self._open_issues[project_id] = {}
                    page = 1
                    while True:
                        issues = self.service_cred('mc_project_get_issues', project_id=project_id, page_number=page, per_page=per_page, **kwopts)
                        for issue in issues:
                            self._open_issues[project_id][issue.id] = issue
                        if len(issues) < per_page:
                            break
                        page += 1
        ret = dict()
        for project_id in project_ids or self._open_issues.keys():
            ret.update(self._open_issues[project_id])
        return ret

    def get_closed_issues(self, project_ids=None, **kwopts):
        if self._closed_issues is None:
            self._closed_issues = {}
            if not project_ids:
                project_ids = self.get_projects(**kwopts).keys()
            import suds
            max_id = 0
            for project_id in project_ids:
                max_id = max(max_id, self.service_cred('mc_issue_get_biggest_id', project_id=project_id, **kwopts))
            open_issues = self.get_open_issues(project_ids, **kwopts)
            for id in xrange(1, max_id + 1):
                if id not in open_issues:
                    try:
                        issue = self.service_cred('mc_issue_get', issue_id=id, exception_fatal=False, **kwopts)
                        self._closed_issues[issue.id] = issue
                    except suds.WebFault, e:
                        pass
        ret = dict()
        for issue_id, issue in self._closed_issues.iteritems():
            if project_ids is None or issue.project.id in project_ids:
                ret[issue_id] = issue
        return ret

    def get_issues(self, project_ids=None, **kwopts):
        ret = dict()
        if self.include_open or not self.include_closed:
            ret.update(self.get_open_issues(project_ids, **kwopts))
        if self.include_closed or not self.include_open:
            ret.update(self.get_closed_issues(project_ids, **kwopts))
        return ret

    def _invalidate_issue(self, mantis_issue_id):
        try:
            del self._open_issues[mantis_issue_id]
        except (TypeError, KeyError):
            pass
        try:
            del self._closed_issues[mantis_issue_id]
        except (TypeError, KeyError):
            pass

    def extract_issue_references(self, mantis_issue_id):
        r'''Return an iterator over all references to other issues in the text, relationships and
        notes of the given Mantis issue.  Each returned reference may be an int to indicate another
        Mantis issue id, or a GithubIssueRef to indicate a GitHub issue.
        '''
        mantis_issue = self.get_issue(mantis_issue_id)
        if hasattr(mantis_issue, 'relationships') and mantis_issue.relationships:
            for rel in mantis_issue.relationships:
                if rel.type.name == 'related to':
                    yield rel.target_id
        texts = [mantis_issue.description]
        if hasattr(mantis_issue, 'steps_to_reproduce') and mantis_issue.steps_to_reproduce:
            texts.append(mantis_issue.steps_to_reproduce)
        if hasattr(mantis_issue, 'additional_information') and mantis_issue.additional_information:
            texts.append(mantis_issue.additional_information)
        if hasattr(mantis_issue, 'notes') and mantis_issue.notes:
            texts += (note.text for note in mantis_issue.notes)
        for text in texts:
            for ref in GithubInterface.extract_issue_links(text):
                yield ref
            for id in self.extract_referred_mantis_issue_ids(text):
                yield id
            for id in self.extract_linked_mantis_issue_ids(text):
                yield id

    MIGRATION_TEXT = 'This issue is now being tracked on GitHub: '

    def migrated_github_references(self, mantis_issue):
        r'''Return an iterator of GithubIssueRef objects indicating the GitHub issues to which this
        Mantis issue is marked has having been migrated.  This does not check that the GitHub issues
        are consistent, ie, are not deleted and are marked has having originated from the same
        Mantis issue.
        '''
        if hasattr(mantis_issue, 'notes') and mantis_issue.notes:
            for note in mantis_issue.notes:
                ref = self.migrated_github_reference(note=note)
                if ref:
                    yield ref

    def migrated_github_reference(self, issue=None, note=None, text=None):
        '''Return a GithubIssueRef indicating the GitHub issue to which this Mantis issue has
        already been migrated.
        '''
        if text is not None:
            text = text.lstrip()
            if text.startswith(self.MIGRATION_TEXT):
                try:
                    return GithubInterface.parse_issue_url(text[len(self.MIGRATION_TEXT):].split()[0])
                except (IndexError, ValueError): pass
            return None
        elif note is not None:
            return self.migrated_github_reference(text= note.text if hasattr(note, 'text') and note.text else '')
        else:
            refs = list(self.migrated_github_references(issue))
            return refs[-1] if refs else None

    def add_note(self, mantis_issue_id, note_text):
        note = self.client().factory.create('IssueNoteData')
        note.text = note_text
        self.service_cred('mc_issue_note_add', issue_id=mantis_issue_id, note=note)
        self._invalidate_issue(mantis_issue_id)

    def update_status(self, mantis_issue_id, status=None, resolution=None):
        issue = self.get_issue(mantis_issue_id)
        self._invalidate_issue(mantis_issue_id)
        if status:
            issue.status = self.get_enum_status(status)
        if resolution:
            issue.resolution = self.get_enum_resolutions(resolution)
        return self.service_cred('mc_issue_update', issueId=mantis_issue_id, issue=issue)

class GithubIssueRef(object):
    org_name = None
    repo_name = None
    issue_number = None

    def __init__(self, org_name, repo_name, issue_number):
        self.org_name = org_name
        self.repo_name = repo_name
        self.issue_number = issue_number

    def __eq__(self, other):
        return self.same_repo(other) and self.issue_number == other.issue_number

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(self.org_name) | hash(self.repo_name) | self.issue_number

    def __str__(self):
        return self.markdown()

    def __repr__(self):
        return '%s(%r, %r, %r)' % (self.__class__.__name__, self.org_name, self.repo_name, self.issue_number)

    def markdown(self, target_repo_ref=None):
        if target_repo_ref and self.org_name == target_repo_ref.org_name and self.repo_name == target_repo_ref.repo_name:
            return '#%u' % self.issue_number
        return '%s/%s#%u' % (self.org_name, self.repo_name, self.issue_number)

    def same_repo(self, other):
        return isinstance(other, GithubIssueRef) and other.org_name == self.org_name and other.repo_name == self.repo_name

    def other(self, issue_number):
        return GithubIssueRef(self.org_name, self.repo_name, issue_number)

    @classmethod
    def fromstr(cls, text, relative_issue=None):
        obj = cls()
        m = re.match(r'(?:([^/]+)/(^[/#]+))?#(\d+)$', text)
        if not m:
            raise ValueError(text)
        if m.group(1) and m.group(2):
            obj.org_name = m.group(1)
            obj.repo_name = m.group(2)
        elif relative_issue and relative_issue.org_name and relative_issue.repo_name:
            obj.org_name = relative_issue.org_name
            obj.repo_name = relative_issue.repo_name
        else:
            raise ValueError(text)
        obj.issue_number = int(m.group(3))
        return obj

class GithubInterface(DebuggableObject):
    debug_enabled = False
    login = None
    password = None
    default_org_name = None
    user_tokens = ()
    _main = None
    _connections = ()

    def debugtag(self):
        return 'GitHub'

    def read_config(self, cp):
        try:
            self.login = cp.get('github', 'login', False, os.environ)
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            pass
        try:
            self.password = cp.get('github', 'password', False, os.environ)
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            pass
        try:
            self.default_org_name = cp.get('github', 'org', False, os.environ)
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            pass
        self.user_tokens = {}
        try:
            for key, value in cp.items('github users'):
                self.user_tokens[key] = cp.get('github users', key, False, os.environ)
        except ConfigParser.NoSectionError:
            pass

    def main(self):
        if not self._main:
            self._main = GithubConnection(self)
            self._main.login = self.login
            self._main.password = self.password
        return self._main

    def connection(self, login):
        if not self._connections:
            self._connections = {}
        if login not in self._connections:
            conn = None
            if login in self.user_tokens:
                conn = GithubConnection(self)
                conn.login = login
                conn.token = self.user_tokens[login]
            self._connections[login] = conn
        return self._connections[login]

    def default_connection(self):
        return self.connection(self.login)

    @classmethod
    def extract_issue_refs(cls, mdtext, repo_ref=None):
        for match in re.finditer(r'\(\b([^/\s]+)/([^/\s]+)\)#(\d+)\b', mdtext):
            if match.group(1) and match.group(2):
                yield GithubIssueRef(match.group(1), match.group(2), int(match.group(3)))
            elif repo_ref:
                yield repo_ref.other(int(match.group(3)))

    @classmethod
    def extract_issue_links(cls, text):
        for match in re.finditer(r'\bhttps?://\(api\.github\.com/repos|github\.com\)/([^/\s]+)/([^/\s]+)/issues/(\d+)\b', text):
            yield GithubIssueRef(match.group(1), match.group(2), int(match.group(3)))

    @classmethod
    def parse_issue_url(cls, text):
        if text.startswith('https://'):
            text = text[8:]
        elif text.startswith('http://'):
            text = text[7:]
        else:
            return None
        if text.startswith('api.github.com/repos/'):
            text = text[21:]
        elif text.startswith('github.com/'):
            text = text[11:]
        else:
            return None
        a = text.split('/')
        if len(a) == 4 and len(a[0]) and len(a[1]) and a[2] == 'issues' and a[3].isdigit():
            return GithubIssueRef(a[0], a[1], int(a[3]))
        return None

    @classmethod
    def user_str(cls, user):
        if not user:
            return 'None'
        r = [user.login]
        if user.name:
            r += [repr(user.name)]
        if user.email:
            r += ['<%s>' % user.email]
        return ' '.join(r)

class GithubConnection(DebuggableObject):
    interface = None
    login = None
    password = None
    token = None
    _object = None
    _orgs = None

    def __init__(self, interface):
        self.interface = interface

    def debugtag(self):
        return self.interface.debugtag() + ' login=%r %s' % (self.login, 'PASSWORD' if self.password else 'TOKEN' if self.token else 'None')

    def open(self):
        if not self._object:
            self.debug('connect')
            import github
            if self.password:
                self._object = github.Github(self.login, self.password)
            elif self.token:
                self._object = github.Github(self.token)
            else:
                fatal('missing GitHub password or token for login %r' % (self.login,))
        return self._object

    def org(self, name=None):
        if name is None:
            name = self.interface.default_org_name
            if not name:
                fatal('GitHub org name not specified: add to config file or use --github-org=NAME')
        if not self._orgs:
            self._orgs = {}
        if name not in self._orgs:
            self._orgs[name] = GithubOrg(self, name)
        return self._orgs[name]

    def issue(self, ref):
        return self.org(ref.org_name).repo(ref.repo_name).issue(ref.issue_number)

class GithubOrg(DebuggableObject):
    name = None
    connection = None
    _object = None
    _repos = None

    def __init__(self, connection, name):
        self.connection = connection
        self.name = name

    def __eq__(self, other):
        return isinstance(other, GithubOrg) and self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __contains__(self, obj):
        if isinstance(obj, GithubIssueRef):
            return obj.org_name == self.name
        if isinstance(obj, GithubIssue):
            return obj.repo.org == self
        if isinstance(obj, GithubRepo):
            return obj.org == self
        return False

    def debugtag(self):
        return self.connection.debugtag() + ' org=%r' % self.name

    def open(self):
        if not self._object:
            conn = self.connection.open()
            self.connection.debug('get_organization(%r)', self.name)
            self._object = conn.get_organization(self.name)
        return self._object

    def repo(self, name):
        if not self._repos:
            self._repos = {}
        if name not in self._repos:
            self._repos[name] = GithubRepo(self, name)
        return self._repos[name]

class GithubRepo(DebuggableObject):
    name = None
    org = None
    ref = None
    _object = None
    _issues = None

    def __init__(self, org, name):
        self.org = org
        self.name = name
        self.ref = GithubIssueRef(self.org.name, self.name, None)

    def __eq__(self, other):
        return isinstance(other, GithubRepo) and self.org == other.org and self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __contains__(self, obj):
        if isinstance(obj, GithubIssueRef):
            return obj in self.org and obj.repo_name == self.name
        if isinstance(obj, GithubIssue):
            return obj.repo == self
        return False

    def debugtag(self):
        return self.org.debugtag() + ' repo=%r' % self.name

    def open(self):
        if not self._object:
            org = self.org.open()
            self.org.debug('get_repo(%r)', self.name)
            self._object = org.get_repo(self.name)
        return self._object

    def issue(self, number):
        assert isinstance(number, int)
        if not self._issues:
            self._issues = {}
        if number not in self._issues:
            self._issues[number] = GithubIssue(self, number)
        return self._issues[number]

    def get_issues(self, state=None):
        if state in ('open', None):
            self.open()
            self.debug('get_issues(state="open")')
            for ghissue in self.open().get_issues(state='open'):
                issue = self.issue(ghissue.number)
                issue._object = ghissue
                yield issue
        if state in ('closed', None):
            self.open()
            self.debug('get_issues(state="closed")')
            for ghissue in self.open().get_issues(state='closed'):
                issue = self.issue(ghissue.number)
                issue._object = ghissue
                yield issue

    def new_issue(self):
        return GithubIssue(self, None)

    def _created(self, issue):
        if not self._issues:
            self._issues = {}
        self._issues[issue.number] = issue

class GithubIssue(DebuggableObject):
    number = None
    repo = None
    ref = None
    _object = None
    _dry_run_numbers = [0]

    def __init__(self, repo, number):
        self.repo = repo
        self.number = number
        self.ref = GithubIssueRef(self.repo.org.name, self.repo.name, self.number)

    def __eq__(self, other):
        return isinstance(other, GithubIssue) and self.repo == other.repo and self.number is not None and self.number == other.number

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(self.ref)

    def __repr__(self):
        return '%s(%r, %r, %r)' % (self.__class__.__name__, self.repo.org.name, self.repo.name, self.number)

    def debugtag(self):
        return self.repo.debugtag() + ' issue=%r' % self.number

    def markdown(self, target_repo_ref=None):
        return self.ref.markdown(target_repo_ref)

    def open(self):
        if not self._object:
            assert self.number is not None
            repo = self.repo.open()
            self.repo.debug('get_issue(%r)', self.number)
            if self.number > 0:
                self._object = repo.get_issue(self.number)
        return self._object

    def create(self, title, body, labels, dry_run=False):
        assert self._object is None
        assert self.number is None
        repo = self.repo.open()
        self.repo.debug('create_issue(%s)', self._args_str(title=title, body=body, labels=labels))
        if dry_run:
            self._dry_run_numbers[0] -= 1
            self.number = self._dry_run_numbers[0]
        else:
            self._object = repo.create_issue(title=title, body=body, labels=labels)
            self.number = self._object.number
        self.ref = GithubIssueRef(self.repo.org.name, self.repo.name, self.number)
        self.repo._created(self)
        return self._object

    def edit(self, dry_run=False, **kwargs):
        self.open()
        self.debug('edit(%s)', self._args_str(**kwargs))
        if not dry_run and self.number > 0:
            # Issue.edit(labels=) takes list of strings, not Label objects.
            if 'labels' in kwargs:
                kwargs['labels'] = [label.name for label in kwargs['labels']]
            self._object.edit(**kwargs)
        return self._object

    def delete(self, state=None, dry_run=False):
        kwargs = dict(title="DELETED", body="", labels=[], milestone=None, assignee=None)
        if state is not None:
            kwargs['state'] = state
        self.edit(dry_run=dry_run, **kwargs)
        if self._object and self._object.comments:
            self.debug('get_comments()')
            for comment in self.open().get_comments():
                self.debug('comment=%r delete()', comment.id)
                if not dry_run:
                    comment.delete()

    @staticmethod
    def _args_str(**kwargs):
        r = []
        for name, arg in kwargs.iteritems():
            if name == 'labels':
                arg = '[' + ','.join(getattr(label, 'name', 'None') for label in arg) + ']'
            elif name == 'milestone':
                arg = repr(arg and arg.title)
            elif name == 'assignee':
                arg = repr(arg and arg.login)
            else:
                arg = repr(arg)
            r.append('%s=%s' % (name, arg))
        return ', '.join(r)

    def is_deleted(self):
        self.open()
        return self._object.comments == 0 and self._object.title == 'DELETED'

    MIGRATION_TEXT = 'Originally reported as '

    def is_migrated_from(self, mantis, mantis_issue_id):
        self.open()
        if not self._object.comments:
            return False
        self.debug('get_comments()')
        comments = list(self._object.get_comments())
        return comments and comments[0].body.startswith(self.MIGRATION_TEXT) and mantis.issue_link_markdown(mantis_issue_id) in comments[0].body

    def issue_refs(self):
        self.open()
        for ref in GithubInterface.extract_issue_refs(self._object.body, self.ref):
            yield ref
        for ref in GithubInterface.extract_issue_links(self._object.body):
            yield ref
        if self._object.comments:
            self.debug('get_comments()')
            comments = list(self._object.get_comments())
            for comment in comments:
                for ref in GithubInterface.extract_issue_refs(comment.body, self.ref):
                    yield ref
                for ref in GithubInterface.extract_issue_links(comment.body):
                    yield ref

    def dump(self):
        print 'number', '=', self.number
        if self._object is not None:
            print 'title', '=', self._object.title
            print 'state', '=', self._object.state
            print 'milestone', '=', self.milestone_str(self._object.milestone)
            print 'labels', '=', ', '.join(label.name for label in self._object.labels)
            print 'created_at', '=', self._object.created_at
            print 'updated_at', '=', self._object.updated_at
            print 'user', '=', GithubInterface.user_str(self._object.user)
            print 'assignee', '=', GithubInterface.user_str(self._object.assignee)
            print 'repository', '=', self._object.repository
            print 'pull_request', '=', self._object.pull_request.html_url if self._object.pull_request else 'None'
            print 'id', '=', self._object.id
            print 'html_url', '=', self._object.html_url
            print 'url', '=', self._object.url
            print 'closed_at', '=', self._object.closed_at
            print 'closed_by', '=', GithubInterface.user_str(self._object.closed_by)
            print 'body', '=', self._object.body
            print 'comments', '=', self._object.comments
            if self._object.comments:
                for i, comment in enumerate(self._object.get_comments()):
                    print '-------------------- comment', i + 1, '--------------------'
                    self.dump_comment(comment)

    @classmethod
    def milestone_str(cls, milestone):
        return '%s (%s) %s' % (milestone.number, milestone.due_on, milestone.title) if milestone else repr(milestone)

    @classmethod
    def dump_comment(cls, comment):
        print 'user', '=', GithubInterface.user_str(comment.user)
        print 'created_at', '=', comment.created_at
        print 'updated_at', '=', comment.updated_at
        print 'id', '=', comment.id
        print 'url', '=', comment.url
        print 'body', '=', comment.body


class Context(DebuggableObject):
    debug_enabled = False
    dry_run = False
    close_github = False
    no_close_mantis = False
    opts = None
    mantis = MantisInterface()
    github = GithubInterface()
    user_map = ()
    _issue_map = None

    def read_config_file(self):
        path = self.config_path
        if os.path.exists(path):
            stat = os.stat(path)
            if stat.st_uid != os.getuid():
                logging.warn("%s exists but is owned by uid %s (should be %s) -- ignored" % (path, stat.st_uid, getuid()))
            elif stat.st_mode & 0177:
                logging.warn("%s exists but has mode %#o (should be at most 0600) -- ignored" % (path, stat.st_mode & 0777))
            else:
                cp = ConfigParser.SafeConfigParser()
                cp.optionxform = str
                cp.readfp(file(path))
                self.mantis.read_config(cp)
                self.github.read_config(cp)
                self.user_map = {}
                try:
                    for key, value in cp.items('user map'):
                        self.user_map[key] = cp.get('user map', key, False, os.environ)
                except ConfigParser.NoSectionError:
                    pass

    def map_user(self, mantis_user):
        '''Convert a Mantis AccountData object into a GitHub NamedUser object.'''
        if mantis_user is None:
            return None
        login = self.user_map.get(mantis_user.name, None)
        if not login:
            return None
        return self.github.main().open().get_user(login)

    def resolve_user(self, mantis_account):
        '''Convert a Mantis AccountData object into a GitHub AuthenticatedUser object, plus some
        text that can be used to link to the user.
        '''
        login = self.user_map.get(mantis_account.name)
        ghc, ref = None, None
        if login is None:
            ref = self.mantis.user_markdown(mantis_account)
            self.debug('mantis user %r does not resolve to GitHub user', mantis_account.name)
        else:
            ref = '@' + login
            ghc = self.github.connection(login)
            self.debug('resolved mantis user %r to GitHub %r %s', mantis_account.name, ref, '(auth)' if ghc else '(no auth)')
        return ghc, ref

    def mantis_issue_refs(self, mantis_issue_id, target_issue_ref=None):
        r'''Return an interator over references for the given Mantis issue.  If the issue has been
        migrated to any GitHub issues (other than the target issue), then this will iterate over one
        or more GithubIssueRef objects (excluding the target issue).  Otherwise, it will iterate
        over a single int, which is the Mantis issue number.
        '''
        github_refs = list(self.mantis_github_issue_refs(mantis_issue_id))
        try: github_refs.remove(target_issue_ref)
        except ValueError: pass
        if github_refs:
            for ref in github_refs:
                yield ref
        else:
            yield mantis_issue_id

    def mantis_issue_link_markdown(self, mantis_issue_id, target_issue_ref=None, linkset=None):
        r'''Return an iterator over markdown references for the given Mantis issue.  If the issue
        has been migrated to any GitHub issues, then this will iterate over GitHub Flavoured
        Markdown references to those GitHub issues.  Otherwise, it will return a standard Markdown
        link to the Mantis issue itself.
        '''
        for ref in self.mantis_issue_refs(mantis_issue_id, target_issue_ref=target_issue_ref):
            linkset.add(ref)
            yield ref.markdown(target_issue_ref) if isinstance(ref, GithubIssueRef) else self.mantis.issue_link_markdown(mantis_issue_id)

    def mantis_github_issue_refs(self, mantis_issue_id):
        r'''Return an iterable over all GitHub references to which a given Mantis issue has been
        migrated.  It does not return references to GitHub issues that are marked as deleted or
        which are inconsistent.  Ie, the only GitHub issues returned are those which are marked
        as having originated from the given Mantis issue.
        '''
        if self._issue_map is None:
            self._issue_map = {}
        if mantis_issue_id not in self._issue_map:
            mantis_issue = self.mantis.get_issue(mantis_issue_id)
            refs = []
            for ref in self.mantis.migrated_github_references(mantis_issue):
                issue = self.github.default_connection().issue(ref)
                if not issue.is_deleted() and issue.is_migrated_from(self.mantis, mantis_issue_id):
                    refs.append(ref)
            self._issue_map[mantis_issue_id] = refs
        return iter(self._issue_map[mantis_issue_id])

    def add_mantis_github_issue_ref(self, mantis_issue_id, ref):
        r'''Add the given GitHub issue ref to the list of issues to which the given Mantis issue
        has been Migrated.
        '''
        if ref not in self.mantis_github_issue_refs(mantis_issue_id):
            self._issue_map[mantis_issue_id].append(ref)

    def relink_markdown(self, text, github_issue_ref, linkset=None):
        r'''In the given markdown test, replace all links to migrated Mantis issues with their
        equivalent GitHub reference, except for those which have been migrated to a given target
        GitHub issue.
        '''
        return self.mantis.rewrite_markdown_links(text, lambda id: ' '.join(self.mantis_issue_link_markdown(id, github_issue_ref, linkset=linkset)))

    def escape_markdown(self, text):
        return re.subn(r'[\\`*_{}\[\]()#+\-.!]', r'\\\g<0>', text)[0]

    def text_to_markdown(self, text, target_issue_ref=None, linkset=None):
        # Remove leading blank lines.
        text = re.sub(r'^( *\n)+', '', text)
        # If it looks like a stack trace or log file, then preformat it.  Otherwise, remove
        # unintended Markdown effects.
        if (    len(re.findall(r'\bat .*\(.*\.java:[0-9]+\)', text)) >= 3
            or  len(re.findall(r'^ *(DEBUG|WARN|INFO|ERROR):', text, flags=re.MULTILINE)) >= 3
            or  len(re.findall(r'^ *[EWIDV]/', text, flags=re.MULTILINE)) >= 3
            ):
            # WARNING for bug in GitHub API.
            percents = re.findall(r'%(?![0-9A-Fa-f]{2})', text)
            if percents:
                logging.warn(
r'''Preformat text contains %u occurence%s of '%%' character not
followed by two hex digits, which would cause api.github.com to return a
500 Server Error, so every occurrence is replaced with &#37;.  You will
need to manually edit the text to revert these to '%%' characters.
See https://github.com/jacquev6/PyGithub/issues/87''' %
                        (len(percents), 's' if len(percents) != 1 else '')
                    )
            text = '```\n' + text + '\n```'
        else:
            # Remove trailing newlines and blank lines.
            text = text.rstrip()
            # Reduce indents or four or more spaces to three spaces, to avoid
            # them being formatted as code.
            text = re.subn(r'^ {4,}', '   ', text, flags=re.MULTILINE)[0]
            # Convert Mantis issue references (#N) into links to Mantis links.
            text = re.subn(r'#(\d+)', lambda match: ' '.join(self.mantis_issue_link_markdown(int(match.group(1)), target_issue_ref, linkset=linkset)), text)[0]
            # Convert GitHub issue links to references.
            if target_issue_ref:
                def replace_link(match):
                    ref = GithubIssueRef(match.group(1), match.group(2), int(match.group(3)))
                    if linkset is not None:
                        linkset.add(ref)
                    return ref.markdown(target_issue_ref)
                text = re.subn(r'\bhttps?://github.com/([^\s/]+)/([^\s/]+)/issues/(\d+)\b', replace_link, text)[0]
        # Convert links to already-migrated Mantis issues to their equivalent references to GitHub
        # issues.
        def make_link(mantis_issue_id):
            return ' '.join(self.mantis_issue_link_markdown(mantis_issue_id, target_issue_ref, linkset=linkset))
        text = self.mantis.rewrite_markdown_links(text, make_link)
        # WORKAROUND for bug in GitHub API: replace percent signs that are not followed by two hex
        # digits with HTML escape.
        text = re.subn(r'%(?![0-9A-Fa-f]{2})', '&#37;', text)[0]
        return text

    def relink(self, todo, repo_ref=None):
        r'''Given an iterable over various objects: GithubIssueRef, GithubIssue and int (Mantis
        issue id), re-link all the body and comment texts of them and all related GitHub issues.
        '''
        todo = set(todo)
        done = set()
        while todo:
            self.debug('relink todo = %s', ' '.join(str(obj) if isinstance(obj, int) else obj.markdown(repo_ref) for obj in todo))
            obj = todo.pop()
            if isinstance(obj, GithubIssueRef):
                obj = self.github.default_connection().issue(obj)
            if isinstance(obj, GithubIssue):
                assert obj.ref not in done
                done.add(obj.ref)
                more_todo = set()
                self.relink_github_issue(obj, more_todo)
                todo |= more_todo - done
            else:
                done.add(obj)
                assert isinstance(obj, int)
                todo |= set(self.mantis.extract_issue_references(obj)) - done

    def relink_github_issue(self, issue, linkset=None):
        r'''Relink all the body and comment texts in the given GitHub issue.
        '''
        issue.debug('relink')
        if issue.open() is not None:
            body = self.relink_markdown(issue.open().body, issue.ref, linkset=linkset)
            if body != issue.open().body:
                issue.edit(body=body, dry_run=self.dry_run)
            if issue.open().comments:
                issue.debug('get_comments()')
                for comment in issue.open().get_comments():
                    if not comment.body.startswith(GithubIssue.MIGRATION_TEXT):
                        body = self.relink_markdown(comment.body, issue.ref, linkset=linkset)
                        if body != comment.body:
                            issue.debug('comment=%r edit(body=%r)', comment.id, body)
                            if not self.dry_run:
                                comment.edit(body=body)

if __name__ == '__main__':
    main()
