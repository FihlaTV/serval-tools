#!/usr/bin/env python

'''Usage:
    sp-mantis2github [options] mantis version
    sp-mantis2github [options] mantis wsdl
    sp-mantis2github [options] mantis list projects
    sp-mantis2github [options] mantis list project users [<project-id>]
    sp-mantis2github [options] mantis list enum status
    sp-mantis2github [options] mantis list enum resolutions
    sp-mantis2github [options] mantis list issue users
    sp-mantis2github [options] mantis list issues [<project-id>] [-C|--closed] [-O|--open]
    sp-mantis2github [options] mantis dump project <project-id>
    sp-mantis2github [options] mantis dump issue <issue-id>
    sp-mantis2github [options] mantis add note <issue-id> <text>
    sp-mantis2github [options] github register
    sp-mantis2github [options] github list users
    sp-mantis2github [options] github list repos
    sp-mantis2github [options] github list issues <repo-name>
    sp-mantis2github [options] github dump issue <repo-name> <issue-number>
    sp-mantis2github [options] github unset milestone <repo-name> <issue-number>
    sp-mantis2github [options] github unset assignee <repo-name> <issue-number>
    sp-mantis2github [options] migrate <issue-id> <repo-name> [<github-issue-number>]
    sp-mantis2github -h | --help
    sp-mantis2github --version
Options:
    -h --help               Show this message
    --version               Show version and exit
    -D --debug              Enable debug logging
    -n --dry-run            Do not write to GitHub, do queries only
    -t --testing            When migrating, do not modify the original Mantis issue; normally
                            a note is added to the issue linking to its GitHub successor, and
                            the Mantis issue is closed with "suspended" resolution
    -f --force              When migrating, continue even if the issue is already migrated
    -b --behalf             When migrating, create GitHub issue and comments on behalf of
                            original Mantis reporters; without this option will fail if the
                            Mantis issue or any comment is by a user who cannot be mapped to
                            an authorised GitHub user
    --config=PATH           Read config file [default: $HOME/.mantis2github]
    --mantis-url=URL        Connect to Mantis SOAP service at this URL (default taken from
                            $SERVAL_MANTIS_URL/api/soap/mantisconnect.php if set, or config file)
    --mantis-user=USER      Connect to Mantis with this user name (overrides config file)
    --mantis-password=PASS  Connect to Mantis with this password (overrides config file)
    --github-login=USER     Connect to GitHub with this user name (overrides config file)
    --github-password=PASS  Connect to GitHub with this password (overrides config file)
    -C --closed             When listing issues or users of issues, only include closed issues;
                            When migrating, close GitHub issue after migration is done
    -O --open               When listing issues, only include open issues

The config file is in INI format.  It contains user names and passwords in the clear so it is
ignored unless owned by the caller and permissions are at most 0600.
'''

myname = 'sp-mantis2github'
myversion = '0.9'
myorg = 'servalproject'
myurl = 'https://github.com/' + myorg + '/serval-tools/blob/master/bin/' + myname

import sys
import traceback
import os
import os.path
import logging
import ConfigParser
import datetime
import urllib2
import re

def main():
    logging.basicConfig(level=logging.INFO)
    logging.getLogger('suds').setLevel(logging.CRITICAL)
    sys.path.append(os.path.join(serval_tools_root(), "python/docopt"))
    sys.path.append(os.path.join(serval_tools_root(), "python/PyGithub"))
    import docopt
    import github
    cx = Context()
    cx.opts = docopt.docopt(__doc__, version=myversion)
    #print cx.opts
    cx.mantis.url = os.environ.get('SERVAL_MANTIS_URL')
    cx.read_config_file(os.path.expanduser(os.path.expandvars(cx.opts['--config'])))
    if cx.opts['--debug']:
        cx.debug = True
        cx.mantis.debug = True
        cx.github.debug = True
    cx.dry_run = cx.opts['--dry-run']
    cx.testing = cx.opts['--testing']
    cx.force = cx.opts['--force']
    cx.behalf = cx.opts['--behalf']
    cx.mantis.url = cx.opts['--mantis-url'] or cx.mantis.url
    cx.mantis.user = cx.opts['--mantis-user'] or cx.mantis.user
    cx.mantis.password = cx.opts['--mantis-password'] or cx.mantis.password
    cx.github.login = cx.opts['--github-login'] or cx.github.login
    cx.github.password = cx.opts['--github-password'] or cx.github.password
    if cx.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    if cx.mantis.debug:
        logging.getLogger('suds').setLevel(logging.INFO)
    try:
        if cx.opts['mantis']:
            if cx.opts['wsdl']:
                print cx.mantis.client()
            elif cx.opts['version']:
                print cx.mantis.service('mc_version')
            elif cx.opts['list'] and cx.opts['projects']:
                projects = cx.mantis.service_cred('mc_projects_get_user_accessible')
                projects.sort(key=lambda p: p.id)
                for project in projects:
                    print '%-5s %-15s %-15s %-40s' % (project.id, project.status.name, project.view_state.name, project.name)
            elif cx.opts['dump'] and cx.opts['project']:
                try:
                    project_id = int(cx.opts['<project-id>'])
                except ValueError:
                    fatal('invalid <project-id>')
                projects = cx.mantis.service_cred('mc_projects_get_user_accessible')
                for project in projects:
                    if project.id == project_id:
                        print project
            elif cx.opts['dump'] and cx.opts['issue']:
                try:
                    mantis_issue_id = int(cx.opts['<issue-id>'])
                except ValueError:
                    fatal('invalid <issue-id>')
                print cx.mantis.get_issue(mantis_issue_id)
            elif cx.opts['list'] and cx.opts['project'] and cx.opts['users']:
                project_ids = []
                if cx.opts['<project-id>']:
                    try:
                        project_ids.append(int(cx.opts['<project-id>']))
                    except ValueError:
                        fatal('invalid <project-id>')
                all_users = cx.mantis.get_users(project_ids)
                for user in all_users.itervalues():
                    values = (getattr(user, 'name', ''), getattr(user, 'real_name', ''), getattr(user, 'email', ''))
                    if values != ('', '', ''):
                        print '%-20s %-30s %s' % values
            elif cx.opts['list'] and cx.opts['issue'] and cx.opts['users']:
                all_issues = list(cx.filter_mantis_issues(cx.mantis.get_issues().values()))
                users = {}
                for issue in all_issues:
                    try:
                        users[issue.reporter.id] = issue.reporter
                    except AttributeError:
                        pass
                    try:
                        users[issue.handler.id] = issue.handler
                    except AttributeError:
                        pass
                users = users.values()
                users.sort(key=lambda u: (getattr(u, 'name', ''), getattr(u, 'real_name', '')))
                for user in users:
                    values = (getattr(user, 'name', ''), getattr(user, 'real_name', ''), getattr(user, 'email', ''))
                    if values != ('', '', ''):
                        print '%-20s %-30s %s' % values
            elif cx.opts['list'] and cx.opts['enum'] and cx.opts['status']:
                for elt in cx.mantis.get_enum_status():
                    print elt
            elif cx.opts['list'] and cx.opts['enum'] and cx.opts['resolutions']:
                for elt in cx.mantis.get_enum_resolutions():
                    print elt
            elif cx.opts['list'] and cx.opts['issues']:
                project_ids = []
                if cx.opts['<project-id>']:
                    try:
                        project_ids.append(int(cx.opts['<project-id>']))
                    except ValueError:
                        fatal('invalid <project-id>')
                all_issues = list(cx.filter_mantis_issues(cx.mantis.get_issues(project_ids).values()))
                all_issues.sort(key=lambda p: p.id)
                for issue in all_issues:
                    flags = [' '] * 2
                    if getattr(issue, 'attachments', None):
                        flags[0] = 'A'
                    if getattr(issue, 'relationships', None):
                        flags[1] = 'R'
                    print '%-5s %-10s %-10s %s %s' % (issue.id, issue.status.name, issue.resolution.name, ''.join(flags), issue.summary)
            elif cx.opts['add'] and cx.opts['note']:
                try:
                    mantis_issue_id = int(cx.opts['<issue-id>'])
                except ValueError:
                    fatal('invalid <issue-id>')
                text = cx.opts['<text>']
                logging.debug('Mantis add_note(%r, %r)' % (mantis_issue_id, text))
                if not cx.dry_run:
                    cx.mantis.add_note(mantis_issue_id, text)
        elif cx.opts['github']:
            if cx.opts['register']:
                root = cx.github.main().root()
                logging.debug('%s get_user()' % (cx.github.main().debugtag(),))
                ghuser = root.get_user()
                scopes = ['public_repo']
                note = myname + ' version ' + myversion
                logging.debug('%s create_authorization(scopes=%r, note=%r)' % (cx.github.main().debugtag(), scopes, note))
                if not cx.dry_run:
                    auth = ghuser.create_authorization(scopes=scopes, note=note)
                    print auth.token
            elif cx.opts['list'] and cx.opts['users']:
                org = cx.github.default_connection().org()
                logging.debug('%s get_members()' % (cx.github.default_connection(org=org).debugtag(),))
                users = list(org.get_members())
                users.sort(key=lambda u: (u.login, u.name))
                for user in users:
                    print '%-20s %-30s %s' % (user.login, user.name or '', user.email or '')
            elif cx.opts['list'] and cx.opts['repos']:
                org = cx.github.default_connection().org()
                logging.debug('%s get_repos()' % (cx.github.default_connection(org=org).debugtag(),))
                repos = org.get_repos()
                for repo in repos:
                    print repo.name
            elif cx.opts['list'] and cx.opts['issues']:
                repo_name = cx.opts['<repo-name>']
                repo = cx.github.default_connection().repo(repo_name)
                all_issues = []
                if cx.opts['--open'] or not cx.opts['--closed']:
                    logging.debug('%s get_issues(state="open")' % (cx.github.default_connection().debugtag(repo=repo),))
                    all_issues += repo.get_issues(state='open')
                if cx.opts['--closed'] or not cx.opts['--open']:
                    logging.debug('%s get_issues(state="closed")' % (cx.github.default_connection().debugtag(repo=repo),))
                    all_issues += repo.get_issues(state='closed')
                all_issues.sort(key=lambda p: p.number)
                for issue in all_issues:
                    print '%-5s %-10s %s' % (issue.number, issue.state, issue.title)
            elif cx.opts['dump'] and cx.opts['issue']:
                repo_name = cx.opts['<repo-name>']
                try:
                    issue_number = int(cx.opts['<issue-number>'])
                except ValueError:
                    fatal('invalid <issue-number>')
                repo = cx.github.default_connection().repo(repo_name)
                logging.debug('%s get_issue(%r)' % (cx.github.default_connection().debugtag(repo=repo), issue_number))
                github_dump_issue(repo.get_issue(issue_number))
            elif cx.opts['unset']:
                repo_name = cx.opts['<repo-name>']
                try:
                    issue_number = int(cx.opts['<issue-number>'])
                except ValueError:
                    fatal('invalid <issue-number>')
                repo = cx.github.default_connection().repo(repo_name)
                logging.debug('%s get_issue(%r)' % (cx.github.default_connection().debugtag(repo=repo), issue_number))
                issue = repo.get_issue(issue_number)
                if cx.opts['milestone']:
                    logging.debug('%s edit(milestone=None)' % (cx.github.default_connection().debugtag(repo=repo, issue=issue)))
                    if not cx.dry_run:
                        issue.edit(milestone=None)
                if cx.opts['assignee']:
                    logging.debug('%s edit(assignee=None)' % (cx.github.default_connection().debugtag(repo=repo, issue=issue)))
                    if not cx.dry_run:
                        issue.edit(assignee=None)
        elif cx.opts['migrate']:
            try:
                mantis_issue_id = int(cx.opts['<issue-id>'])
            except ValueError:
                fatal('invalid <issue-id>')
            repo_name = cx.opts['<repo-name>']
            github_issue_number = None
            if cx.opts['<github-issue-number>']:
                try:
                    github_issue_number = int(cx.opts['<github-issue-number>'])
                except ValueError:
                    fatal('invalid <github-issue-number>')
            # Fetch the original Mantis issue.
            mantis_issue = cx.mantis.get_issue(mantis_issue_id)
            status = getattr(getattr(mantis_issue, 'status', None), 'name', None)
            resolution = getattr(getattr(mantis_issue, 'resolution', None), 'name', None)
            mantis_issue_closed = status in ('closed', 'resolved')
            # Check if it is already migrated.
            migrated_github_ref = cx.mantis.migrated_github_reference(issue=mantis_issue)
            # Resolve the Mantis reporter to a GitHub user.
            authentic_creator_ghc, creator_ref = cx.resolve_user(mantis_issue.reporter)
            if authentic_creator_ghc is None:
                logging.warn('Mantis issue was reported by %s, no equivalent authorised GitHub user' % (mantis_issue.reporter.name,))
                if not cx.behalf:
                    fatal('use --behalf option to migrate issue as GitHub user %s' % (cx.github.default_connection().login,))
                creator_ghc = cx.github.default_connection()
            else:
                creator_ghc = authentic_creator_ghc
            repo = creator_ghc.repo(repo_name)
            target_github_ref = GithubIssueRef()
            target_github_ref.org_name = creator_ghc.org_name
            target_github_ref.repo_name = repo.name
            # Work out whether to create a new GitHub issue or overwrite an existing one.  If the
            # Mantis issue is marked as already migrated to an existing issue in the same repo, then
            # overwrite that issue if --force was given.
            overwrite_issue = None
            delete_issue = None
            deleted_issue = None
            issue = None
            if github_issue_number:
                logging.debug('%s get_issue(%r)' % (creator_ghc.debugtag(repo=repo), github_issue_number))
                issue = repo.get_issue(github_issue_number)
            elif target_github_ref.same_repo(migrated_github_ref):
                logging.debug('%s get_issue(%r)' % (creator_ghc.debugtag(repo=repo), migrated_github_ref.issue_number))
                issue = repo.get_issue(migrated_github_ref.issue_number)
            # If this GitHub issue appears to be a migration of the original Mantis issue (its first
            # comment contains a link back to the Mantis issue) then empty it out and return it to
            # open state.  Otherwise, complain and create a new issue.
            if issue:
                logging.debug('%s get_comments()' % (creator_ghc.debugtag(repo=repo, issue=issue),))
                issue_comments = list(issue.get_comments())
                if migrated_github_ref and issue_comments and cx.mantis.issue_link_markdown(mantis_issue_id) in issue_comments[0].body:
                    logging.warn('Mantis issue %s is already migrated to GitHub %s' % (mantis_issue_id, migrated_github_ref))
                    if not cx.force:
                        fatal('use --force to overwrite existing GitHub issue')
                    delete_issue = issue
                    overwrite_issue = issue
                elif github_issue_number or issue.title == 'DELETED':
                    delete_issue = issue
                    overwrite_issue = issue
                elif migrated_github_ref:
                    logging.warn('Mantis issue %s is marked as migrated to GitHub %s, which does not agree' % (mantis_issue_id, migrated_github_ref))
                    if not cx.force:
                        fatal('use --force to migrate to new GitHub issue')
            if overwrite_issue:
                target_github_ref.issue_number = overwrite_issue.number
            # If we found an existing issue to overwrite and it was created by the wrong GitHub
            # user and we have the correct authorised user now, then delete the old issue and
            # create a new issue.
            if (    overwrite_issue
                and not github_issue_number
                and authentic_creator_ghc
                and overwrite_issue.user.id != authentic_creator_ghc.root().get_user().id):
                logging.warn('deleting GitHub issue %s (user %s) and creating new GitHub issue as user %s' % (
                        target_github_ref, overwrite_issue.user.login, authentic_creator_ghc.login))
                delete_issue = overwrite_issue
                overwrite_issue = None
                target_github_ref.issue_number = None
            # If the --testing option was given, or the Mantis issue is already marked as migrated to
            # the target GitHubIssue and is already closed, then no need to modify the Mantis issue
            # after migrating.  Otherwise, if the Mantis issue is closed, it cannot be modified.
            if not cx.testing:
                mantis_actions = []
                if target_github_ref != migrated_github_ref:
                    mantis_actions += ['add a note to mark it as migrated']
                if status != 'closed' or resolution != 'suspended':
                    mantis_actions += ['close it as suspended']
                if mantis_actions and mantis_issue_closed:
                    logging.warn('Mantis issue %r is %s (%s), so cannot %s' % (mantis_issue_id, status, resolution, ' and '.join(mantis_actions)))
                    fatal('use --testing to leave the Mantis issue unaltered, or reopen the Mantis issue and try again')
            # Discover things about the destination GitHub repo.
            logging.debug('%s get_milestones(state="open")' % (creator_ghc.debugtag(repo=repo),))
            repo_milestones_open = list(repo.get_milestones(state='open'))
            logging.debug('   got %r' % [milestone.title for milestone in repo_milestones_open])
            logging.debug('%s get_milestones(state="closed")' % (creator_ghc.debugtag(repo=repo),))
            repo_milestones_closed = list(repo.get_milestones(state='closed'))
            logging.debug('   got %r' % [milestone.title for milestone in repo_milestones_closed])
            repo_milestones = repo_milestones_open + repo_milestones_closed
            logging.debug('%s get_labels()' % (creator_ghc.debugtag(repo=repo),))
            repo_labels = dict((label.name, label) for label in repo.get_labels())
            logging.debug('   got %r' % list(repo_labels))
            # Create GitHub "mantis" label unless it already exists, in which case make sure it is
            # the right colour.
            label_name = 'mantis'
            label_colour = '034c31' # Mantis logo text colour
            label = repo_labels.get(label_name)
            if label is None:
                logging.debug('%s create_label(name=%r, color=%r)' % (creator_ghc.debugtag(repo=repo), label_name, label_colour))
                if not cx.dry_run:
                    label = repo.create_label(name=label_name, color=label_colour)
                    if not label:
                        fatal('cannot create label %r' % (label_name,))
            elif label.color.lower() != label_colour:
                logging.debug('%s label=%r edit(name=%r, color=%r)' % (creator_ghc.debugtag(repo=repo), label_name, label_name, label_colour))
                if not cx.dry_run:
                    label.edit(name=label_name, color=label_colour)
            # Start assembling the body, comments and labels of the GitHub issue.
            labels = [label]
            body = []
            comments = [] # [(datetime, GithubInterface, str|closemark)]
            closemark = object()
            if not authentic_creator_ghc or (overwrite_issue and overwrite_issue.user.id != authentic_creator_ghc.root().get_user().id):
                body += [creator_ref, ' reported:\n\n']
            body += [cx.text_to_markdown(mantis_issue.description, target_github_ref)]
            # This must be the first comment to make it easy to later detect and cross-reference Mantis
            # issues to GitHub issues.
            comments += [(mantis_issue.date_submitted, creator_ghc,
                    'Originally reported as **' + cx.mantis.issue_link_markdown(mantis_issue.id) + '**' +
                    (' by ' + creator_ref if not authentic_creator_ghc else '') +
                    ' at ' + mantis_issue.date_submitted.ctime() + '.'
                )]
            github_assignee = cx.map_user(getattr(mantis_issue, 'handler', None))
            body += ['\n']
            if hasattr(mantis_issue, 'severity') and mantis_issue.severity:
                body += ['\nMantis severity: **', mantis_issue.severity.name, '**']
            if hasattr(mantis_issue, 'priority') and mantis_issue.priority:
                body += ['\nMantis priority: **', mantis_issue.priority.name, '**']
            if hasattr(mantis_issue, 'project') and mantis_issue.project:
                body += ['\nMantis project: **', mantis_issue.project.name, '**']
            if hasattr(mantis_issue, 'version') and mantis_issue.version:
                body += ['\nProduct version: **', mantis_issue.version, '**']
            target_version = None
            if hasattr(mantis_issue, 'target_version') and mantis_issue.target_version:
                body += ['\nTarget version: **', mantis_issue.target_version, '**']
                target_version = mantis_issue.target_version
            if hasattr(mantis_issue, 'fixed_in_version') and mantis_issue.fixed_in_version:
                body += ['\nFixed in version: **', mantis_issue.fixed_in_version, '**']
                target_version = mantis_issue.fixed_in_version
            # Map target version or fixed-in version to GitHub milestone.
            github_milestone = None
            if target_version:
                target_version = target_version.strip()
                for milestone in repo_milestones:
                    for word in target_version.split():
                        if word not in milestone.title:
                            break
                    else:
                        github_milestone = milestone
                        break
            # Translate Mantis resolution to GitHub label of the same name if it exists, otherwise
            # label as 'duplicate', 'invalid' or 'wontfix' accordingly.
            if resolution in repo_labels: # includes 'duplicate'
                labels += [repo_labels[resolution]]
            elif resolution == 'unable to reproduce':
                if 'invalid' in repo_labels:
                    labels += [repo_labels['invalid']]
                elif 'wontfix' in repo_labels:
                    labels += [repo_labels['wontfix']]
            elif resolution in ('not fixable', "won't fix"):
                if 'wontfix' in repo_labels:
                    labels += [repo_labels['wontfix']]
            # Translate Mantis severity level to GitHub label of the same name if it exists,
            # otherwise label 'feature' and 'tweak' as an enhancement, and all others as bugs.
            if hasattr(mantis_issue, 'severity') and mantis_issue.severity:
                if mantis_issue.severity.name in repo_labels:
                    labels += [repo_labels[mantis_issue.severity.name]]
                elif mantis_issue.severity.name in ('feature', 'tweak'):
                    if 'enhancement' in repo_labels:
                        labels += [repo_labels['enhancement']]
                else:
                    if 'bug' in repo_labels:
                        labels += [repo_labels['bug']]
            # Translate Mantis tags into GitHub tags of the same name, if they exist.
            if hasattr(mantis_issue, 'tags') and mantis_issue.tags:
                body += ['\nMantis tags: ']
                body += ('**%s**' % tag.name for tag in mantis_issue.tags)
                for tag in mantis_issue.tags:
                    if tag.name in repo_labels:
                        labels += [repo_labels[tag.name]]
            if hasattr(mantis_issue, 'relationships') and mantis_issue.relationships:
                related_issue_ids = [rel.target_id for rel in mantis_issue.relationships if rel.type.name == 'related to']
                if related_issue_ids:
                    body += ['\nRelated to: ']
                    body += ' '.join('**%s**' % cx.mantis_issue_ref_markdown(issue_id, target_github_ref) for issue_id in related_issue_ids)
            body += ['\nCan reproduce: **', mantis_issue.reproducibility.name, '**']
            if hasattr(mantis_issue, 'steps_to_reproduce') and mantis_issue.steps_to_reproduce:
                body += ['\nTo reproduce:\n\n', cx.text_to_markdown(mantis_issue.steps_to_reproduce, target_github_ref)]
            if hasattr(mantis_issue, 'additional_information') and mantis_issue.additional_information:
                body += ['\n\n' + cx.text_to_markdown(mantis_issue.additional_information, target_github_ref)]
            title = unicode(mantis_issue.summary)
            body = u''.join(body)
            # Convert Mantis attachments and notes into GitHub comments, and sort them in
            # chronological order.  Check whether the Mantis issue is already noted as migrated to
            # this repo, and if so, to which GitHub issue.
            github_existing_issue = None
            if hasattr(mantis_issue, 'attachments') and mantis_issue.attachments:
                all_users = cx.mantis.get_users([mantis_issue.project.id])
                for attachment in mantis_issue.attachments:
                    attacher_user_id = getattr(attachment, 'user_id', None)
                    attacher_ghc, attacher_ref, attacher_tag = None, None, None
                    if attacher_user_id in all_users:
                        attacher_ghc, attacher_ref = cx.resolve_user(all_users[attacher_user_id])
                    comment_body = []
                    comment_body += ['At ', attachment.date_submitted.ctime()]
                    if not attacher_ghc:
                        logging.warn('Mantis attachment %s has no equivalent authorised GitHub user' % (attachment.filename or '<untitled>',))
                        if not cx.behalf:
                            fatal('use --behalf option to migrate attachments as GitHub user %s' % (cx.github.default_connection().login,))
                        attacher_ghc = cx.github.default_connection()
                        comment_body += [' ', attacher_ref]
                    comment_body += [' attached **[', attachment.filename or 'untitled', '](', attachment.download_url, ')**']
                    if getattr(attachment, 'size', None):
                        comment_body += [', ', str(attachment.size), ' bytes']
                    if getattr(attachment, 'content_type', None):
                        comment_body += [', *', attachment.content_type, '*']
                    comment_body += ['.']
                    comments.append((attachment.date_submitted, attacher_ghc, ''.join(comment_body)))
            if hasattr(mantis_issue, 'notes') and mantis_issue.notes:
                for note in mantis_issue.notes:
                    note_text = note.text.lstrip() if hasattr(note, 'text') and note.text else ''
                    time_tracking = note.time_tracking if hasattr(note, 'time_tracking') else None
                    if note_text or time_tracking and not cx.mantis.migrated_github_reference(text=note_text):
                        noter_ghc, noter_ref = cx.resolve_user(note.reporter)
                        comment_body = []
                        comment_body += ['At ', note.date_submitted.ctime()]
                        if not noter_ghc:
                            logging.warn('Mantis note reported by %s has no equivalent authorised GitHub user' % (note.reporter.name,))
                            if not cx.behalf:
                                fatal('use --behalf option to migrate notes as GitHub user %s' % (cx.github.default_connection().login,))
                            noter_ghc = cx.github.default_connection()
                            comment_body += [' ', noter_ref, ' commented']
                        comment_body += [':']
                        if time_tracking:
                            hours = note.time_tracking / 60
                            minutes = note.time_tracking % 60
                            comment_body += ['\n\nTime spent: **%u:%02u**' % (hours, minutes)]
                        if note_text:
                            comment_body += ['\n\n', cx.text_to_markdown(note_text, target_github_ref)]
                        comments.append((note.date_submitted, noter_ghc, ''.join(comment_body)))
            if mantis_issue_closed:
                comments.append((mantis_issue.last_updated, creator_ghc,
                        'At ' + mantis_issue.last_updated.ctime() +
                        ' Mantis issue status **' + status + '**' +
                        (', resolution **' + resolution + '**' if resolution else '') +
                        '.'
                    ))
                comments.append((mantis_issue.last_updated, creator_ghc, closemark))
            elif cx.opts['--closed']:
                comments.append((mantis_issue.last_updated, creator_ghc,
                        'Issue **closed** after migrating from Mantis at ' + mantis_issue.last_updated.ctime() +
                        '.'
                    ))
            migration_body = ['Issue migrated from Mantis to GitHub']
            if not mantis_issue_closed:
                migration_body += [' with Mantis']
                if status:
                    migration_body += [' status **', status, '**']
                if status and resolution:
                    migration_body += [' and']
                if resolution:
                    migration_body += [' resolution **', resolution, '**']
            now = datetime.datetime.now()
            migration_body += [
                    ' at ', now.ctime(),
                    ' using [', myname, '](', myurl, ') version ', myversion
                ]
            comments.append((now, cx.github.default_connection(), ''.join(migration_body)))
            # Having assembled the new GitHub issue, now perform modifications to GitHub.
            issue = None
            if delete_issue:
                # If we are not going to overwrite this issue, then close it as well as deleting it.
                kwargs = dict(title="DELETED", body="", labels=[], milestone=None, assignee=None)
                if overwrite_issue is not delete_issue:
                    kwargs['state'] = 'closed'
                logging.debug('%s edit(%s)' % (creator_ghc.debugtag(issue=delete_issue), ', '.join('%s=%r' % i for i in kwargs.iteritems())))
                if not cx.dry_run:
                    delete_issue.edit(**kwargs)
                logging.debug('%s get_comments()' % (creator_ghc.debugtag(repo=repo, issue=delete_issue),))
                for comment in delete_issue.get_comments():
                    logging.debug('%s delete()' % (creator_ghc.debugtag(issue=delete_issue, comment=comment),))
                    if not cx.dry_run:
                        comment.delete()
                deleted_issue = delete_issue
            if overwrite_issue is None:
                logging.debug('%s create_issue(title=%r body=%r labels=[%s])' % (
                        creator_ghc.debugtag(repo=repo), title, body, ','.join(label.name for label in labels)))
                if not cx.dry_run:
                    issue = repo.create_issue(title=title, body=body, labels=labels)
                    target_github_ref.issue_number = issue.number
            else:
                issue = overwrite_issue
                logging.debug('%s edit(state="open", title=%r, body=%r, labels=[%s])' % (
                        creator_ghc.debugtag(issue=issue), title, body, ','.join(label.name for label in labels)))
                if not cx.dry_run:
                    issue.edit(state='open', title=title, body=body, labels=[label.name for label in labels])
            # Set the GitHub milestone.
            if github_milestone is not None:
                logging.debug('%s edit(milestone=%r)' % (creator_ghc.debugtag(issue=issue), github_milestone.title))
                if not cx.dry_run:
                    issue.edit(milestone=github_milestone)
                    if getattr(issue.milestone, 'id', None) != github_milestone.id:
                        logging.warn('cannot set issue to milestone %r' % (github_milestone.title,))
            # Set the GitHub assignee.
            if github_assignee is not None:
                logging.debug('%s edit(assignee=%r)' % (creator_ghc.debugtag(issue=issue), github_assignee.login))
                if not cx.dry_run:
                    issue.edit(assignee=github_assignee)
                    if getattr(issue.assignee, 'login', None) != github_assignee.login:
                        logging.warn('cannot assign issue to %r -- adding GitHub comment instead' % (github_assignee.login,))
                        comments.insert(1, (mantis_issue.date_submitted, cx.github.default_connection(),
                                'Assigned to Mantis user ' + cx.mantis.user_markdown(mantis_issue.handler) + '.'
                            ))
            # Set the GitHub comments.
            comments.sort(key=lambda c: c[0])
            for commenter_time, commenter_ghc, comment_body in comments:
                commenter_repo = commenter_ghc.repo(repo_name)
                if comment_body is closemark:
                    logging.debug('%s edit(state="closed")' % (commenter_ghc.debugtag(repo=commenter_repo),))
                    if not cx.dry_run:
                        issue.edit(state='closed')
                        if issue.state != 'closed':
                            logging.warn('cannot close issue #%r' % (issue.number,))
                else:
                    logging.debug('%s get_issue(%r)' % (commenter_ghc.debugtag(repo=commenter_repo), target_github_ref.issue_number))
                    commenter_issue = None
                    if not cx.dry_run:
                        commenter_issue = commenter_repo.get_issue(target_github_ref.issue_number)
                    logging.debug('%s create_comment(%r)' % (commenter_ghc.debugtag(repo=commenter_repo, issue=commenter_issue), comment_body))
                    if not cx.dry_run:
                        commenter_issue.create_comment(comment_body)
            # If this issue replaces an existing migration of the same Mantis issue, then put a
            # reference into the deleted issue to point to this one, so that old GitHub
            # references to the deleted one can still be followed to the new one.  This is done
            # _after_ all the migrated comments are added, because it creates a comment in the
            # GitHub issue that should not be the first comment.
            if deleted_issue and overwrite_issue is None:
                body = 'Superceded by #%s' % target_github_ref.issue_number
                logging.debug('%s edit(body=%r)' % (creator_ghc.debugtag(repo=repo, issue=deleted_issue), body))
                if not cx.dry_run:
                    deleted_issue.edit(body=body)
            # Mark the Mantis issue as migrated: add a note linking to the GitHub issue, and close
            # the Mantis issue with resolution "suspended".
            if not cx.testing:
                if target_github_ref != migrated_github_ref:
                    text = MantisInterface.MIGRATION_TEXT + getattr(issue, 'html_url', 'None')
                    logging.debug('Mantis add_note(%r, %r)' % (mantis_issue_id, text))
                    if not cx.dry_run:
                        cx.mantis.add_note(mantis_issue_id, text)
                if status != 'closed' or resolution != 'suspended':
                    logging.debug('Mantis update_status(%r, status=%r, resolution=%r)' % (mantis_issue_id, 'closed', 'suspended'))
                    if not cx.dry_run:
                        cx.mantis.update_status(mantis_issue_id, 'closed', 'suspended')
        # TODO: command to upgrade GitHub links
        #   - description and comment texts that link to an imported Mantis issue should be
        #     edited to refer to the GitHub issue instead
    except IOError, e:
        if cx.mantis.debug:
            traceback.print_exc()
        fatal('%s: %s' % (cx.mantis.url or '<Unknown URL>', e))
    except github.GithubException, e:
        if cx.github.debug:
            traceback.print_exc()
        fatal(e.data.get('message', 'Unknown error'))

def fatal(message):
    logging.critical(message)
    sys.exit(1)

def serval_tools_root():
    return os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))

class MantisInterface(object):

    debug = False
    url = None
    user = None
    password = None
    _client = None

    _enum = None
    _projects = None
    _issues = None
    _issue_map = None

    def read_config(self, cp):
        try:
            self.url = cp.get('mantis', 'url', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.user = cp.get('mantis', 'user', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.password = cp.get('mantis', 'password', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass

    def url_base(self):
        if not self.url:
            fatal("missing Mantis URL")
        try:
            return self.url[:self.url.index('/api/')]
        except ValueError:
            return self.url

    def url_soap(self):
        return self.url_base() + '/api/soap/mantisconnect.php?wsdl'

    def url_issue(self, issue_id):
        return self.url_base() + '/view.php?id=' + str(issue_id)

    def issue_link_markdown(self, mantis_issue_id):
        return '[mantis:' + '%07u' % mantis_issue_id + '](' + self.url_issue(mantis_issue_id) + ')'

    def client(self):
        if not self._client:
            import suds
            url = self.url_soap()
            logging.debug('create Mantis SOAP client, url=%r' % (url,))
            self._client = suds.client.Client(url)
        return self._client

    def user_markdown(self, user):
        if not user:
            return 'None'
        mantis_user_url = self.url_base() + '/view_user_page.php?id=' + str(user.id)
        # Do not include the user's real name or email here, even though it is available via SOAP,
        # because we do not want to put people's email addresses in the clear on GitHub to be harvested
        # by spammers.
        return '**[' + user.name + '](' + mantis_user_url + ')**'

    def service(self, method, **kwargs):
        '''This method exists to create a single code path to invoking SOAP services, that can be
        logged.
        '''
        safe_kwargs = dict(kwargs)
        if 'password' in safe_kwargs:
            safe_kwargs['password'] = '***'
        import suds
        try:
            client = self.client()
            logging.debug('%s(%s)' % (method, ', '.join('%s=%s' % i for i in safe_kwargs.iteritems())))
            return getattr(client.service, method)(**kwargs)
        except suds.WebFault, e:
            if self.debug:
                print >>sys.stderr, '%s(%s)' % (method, ', '.join('%s=%r' % i for i in kwargs.iteritems()))
                traceback.print_exc()
            fatal(e)

    def service_cred(self, method, **kwargs):
        _kwargs = dict(self.credentials())
        _kwargs.update(kwargs)
        return self.service(method, **_kwargs)

    def credentials(self):
        if self.user is None:
            fatal("missing Mantis user name")
        if self.password is None:
            fatal("missing Mantis password")
        return {'username': self.user, 'password': self.password}

    def get_enum(self, enum, name=None, **kwopts):
        if self._enum is None:
            self._enum = {}
        if enum not in self._enum:
            self._enum[enum] = {}
            for elt in self.service_cred('mc_enum_' + enum):
                self._enum[enum][elt.name] = elt
        if name is None:
            return self._enum[enum].values()
        if name not in self._enum[enum]:
            fatal('no name %r in Mantis %r enum' % (name, enum))
        return self._enum[enum][name]

    def get_enum_status(self, name=None, **kwopts):
        return self.get_enum('status', name, **kwopts)

    def get_enum_resolutions(self, name=None, **kwopts):
        return self.get_enum('resolutions', name, **kwopts)

    def get_users(self, project_ids=None, **kwopts):
        if not project_ids:
            project_ids = []
            projects = self.service_cred('mc_projects_get_user_accessible', **kwopts)
            for project in projects:
                project_ids.append(project.id)
        all_users = {}
        for project_id in project_ids:
            users = self.service_cred('mc_project_get_users', project_id=project_id, access=1, **kwopts)
            for user in users:
                all_users[user.id] = user
        return all_users

    def get_projects(self, **kwopts):
        if self._projects is None:
            self._projects = {}
            projects = self.service_cred('mc_projects_get_user_accessible', **kwopts)
            for project in projects:
                self._projects[project.id] = project
        return self._projects

    def get_issue(self, issue_id):
        if self._issues is None:
            self._issues = {}
        if issue_id not in self._issues:
            self._issues[issue_id] = self.service_cred('mc_issue_get', issue_id=issue_id)
        return self._issues[issue_id]

    def get_issues(self, project_ids=None, per_page=100, **kwopts):
        if not project_ids:
            project_ids = self.get_projects(**kwopts).keys()
        all_issues = {}
        if self._issues is None:
            self._issues = {}
        for project_id in project_ids:
            if project_id not in self._issues:
                self._issues[project_id] = {}
                page = 1
                while True:
                    issues = self.service_cred('mc_project_get_issues', project_id=project_id, page_number=page, per_page=per_page, **kwopts)
                    for issue in issues:
                        self._issues[project_id][issue.id] = issue
                    if len(issues) < per_page:
                        break
                    page += 1
            all_issues.update(self._issues[project_id])
        return all_issues

    MIGRATION_TEXT = 'This issue is now being tracked on GitHub: '

    def migrated_github_reference(self, issue=None, note=None, text=None):
        '''Return a GithubIssueRef indicating the GitHub issue to which this Mantis issue has
        already been migrated.
        '''
        if text is not None:
            text = text.lstrip()
            if text.startswith(self.MIGRATION_TEXT):
                try:
                    return GithubInterface.parse_issue_url(text[len(self.MIGRATION_TEXT):].split()[0])
                except (IndexError, ValueError):
                    pass
            return None
        elif note:
            return self.migrated_github_reference(text= note.text if hasattr(note, 'text') and note.text else '')
        elif hasattr(issue, 'notes') and issue.notes:
            ref = None
            for note in issue.notes:
                ref = self.migrated_github_reference(note=note) or ref
            return ref
        return None

    def issue_map(self, **kwopts):
        if self._issue_map is None:
            self._issue_map = {}
            for issue_id, issue in self.get_issues():
                ref = self.migrated_github_reference(issue=issue)
                if ref:
                    self._issue_map[issue_id] = ref
        return self._issue_map

    def add_note(self, mantis_issue_id, note_text):
        note = self.client().factory.create('IssueNoteData')
        note.text = note_text
        self.service_cred('mc_issue_note_add', issue_id=mantis_issue_id, note=note)
        del self._issues[mantis_issue_id]

    def update_status(self, mantis_issue_id, status=None, resolution=None):
        issue = self.get_issue(mantis_issue_id)
        del self._issues[mantis_issue_id]
        if status:
            issue.status = self.get_enum_status(status)
        if resolution:
            issue.resolution = self.get_enum_resolutions(resolution)
        return self.service_cred('mc_issue_update', issueId=mantis_issue_id, issue=issue)

class GithubIssueRef(object):
    org_name = None
    repo_name = None
    issue_number = None

    def github_issue_markdown(self, target_issue):
        if target_issue and self.org_name == target_issue.org_name and self.repo_name == target_issue.repo_name:
            return '#%u' % self.issue_number
        return '%s/%s#%u' % (self.org_name, self.repo_name, self.issue_number)

    def same_repo(self, other):
        return isinstance(other, GithubIssueRef) and other.org_name == self.org_name and other.repo_name == self.repo_name

    def __eq__(self, other):
        return self.same_repo(other) and self.issue_number == other.issue_number

    def __ne__(self, other):
        return not self.__eq__(other)

    def __str__(self):
        return '%s/%s#%u' % (self.org_name, self.repo_name, self.issue_number)

class GithubInterface(object):
    debug = False
    login = None
    password = None
    user_tokens = ()
    _main = None
    _connections = ()

    def read_config(self, cp):
        try:
            self.login = cp.get('github', 'login', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.password = cp.get('github', 'password', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        self.user_tokens = {}
        try:
            for key, value in cp.items('github users'):
                self.user_tokens[key] = cp.get('github users', key, os.environ)
        except ConfigParser.NoSectionError:
            pass

    def main(self):
        if not self._main:
            self._main = GithubConnection()
            self._main.login = self.login
            self._main.password = self.password
        return self._main

    def connection(self, login):
        if not self._connections:
            self._connections = {}
        if login not in self._connections:
            conn = None
            if login in self.user_tokens:
                conn = GithubConnection()
                conn.login = login
                conn.token = self.user_tokens[login]
            self._connections[login] = conn
        return self._connections[login]

    def default_connection(self):
        return self.connection(self.login)

    @classmethod
    def parse_issue_url(cls, text):
        if text.startswith('https://'):
            text = text[8:]
        elif text.startswith('http://'):
            text = text[7:]
        else:
            return None
        if text.startswith('api.github.com/repos/'):
            text = text[21:]
        elif text.startswith('github.com/'):
            text = text[11:]
        else:
            return None
        a = text.split('/')
        if len(a) == 4 and len(a[0]) and len(a[1]) and a[2] == 'issues' and a[3].isdigit():
            ref = GithubIssueRef()
            ref.org_name = a[0]
            ref.repo_name = a[1]
            ref.issue_number = int(a[3])
            return ref
        return None

class GithubConnection(object):
    login = None
    password = None
    token = None
    org_name = myorg
    _root = None
    _org = None
    _repos = None

    def debugtag(self, org=None, repo=None, issue=None, comment=None):
        if issue:
            repo = issue.repository
        if repo:
            org = repo.organization
        r = ['GitHub login=%r' % (self.login,)]
        if org:
            r += ['org=%r' % org.name]
        if repo:
            r += ['repo=%r' % repo.name]
        if issue:
            r += ['issue=%r' % issue.number]
        if comment:
            r += ['comment=%r' % comment.id]
        return ' '.join(r)

    def root(self):
        if not self._root:
            import github
            if self.password:
                logging.debug('connect to GitHub as %r using password' % (self.login,))
                self._root = github.Github(self.login, self.password)
            elif self.token:
                logging.debug('connect to GitHub as %r using token' % (self.login,))
                self._root = github.Github(self.token)
            else:
                fatal('missing GitHub password or token for login %r' % (self.login,))
        return self._root

    def org(self):
        if not self._org:
            root = self.root()
            logging.debug('%s get_organization(%r)' % (self.debugtag(), self.org_name))
            self._org = root.get_organization(self.org_name)
        return self._org

    def repo(self, name):
        if not self._repos:
            self._repos = {}
        if name not in self._repos:
            org = self.org()
            logging.debug('%s get_repo(%r)' % (self.debugtag(org=org), name))
            self._repos[name] = org.get_repo(name)
        return self._repos[name]

class Context(object):
    debug = False
    dry_run = False
    opts = None
    mantis = MantisInterface()
    github = GithubInterface()
    user_map = ()

    def read_config_file(self, path):
        if os.path.exists(path):
            stat = os.stat(path)
            if stat.st_uid != os.getuid():
                logging.warn("%s exists but is owned by uid %s (should be %s) -- ignored" % (path, stat.st_uid, getuid()))
            elif stat.st_mode & 0177:
                logging.warn("%s exists but has mode %#o (should be at most 0600) -- ignored" % (path, stat.st_mode & 0777))
            else:
                cp = ConfigParser.SafeConfigParser()
                cp.optionxform = str
                cp.readfp(file(path))
                self.mantis.read_config(cp)
                self.github.read_config(cp)
                self.user_map = {}
                try:
                    for key, value in cp.items('user map'):
                        self.user_map[key] = cp.get('user map', key, os.environ)
                except ConfigParser.NoSectionError:
                    pass

    def map_user(self, mantis_user):
        '''Convert a Mantis AccountData object into a GitHub NamedUser object.'''
        if mantis_user is None:
            return None
        login = self.user_map.get(mantis_user.name, None)
        if not login:
            return None
        return self.github.main().root().get_user(login)

    def resolve_user(self, mantis_account):
        '''Convert a Mantis AccountData object into a GitHub AuthenticatedUser object, plus some
        text that can be used to link to the user.
        '''
        login = self.user_map.get(mantis_account.name)
        ghc, ref = None, None
        if login is None:
            ref = self.mantis.user_markdown(mantis_account)
            logging.debug('mantis user %r does not resolve to GitHub user' % (mantis_account.name,))
        else:
            ref = '@' + login
            ghc = self.github.connection(login)
            logging.debug('resolved mantis user %r to GitHub %r %s' % (mantis_account.name, ref, '(auth)' if ghc else '(no auth)'))
        return ghc, ref

    def mantis_issue_ref_markdown(self, mantis_issue_id, github_target_issue=None):
        mantis_issue = self.mantis.get_issue(mantis_issue_id)
        ref = self.mantis.migrated_github_reference(issue=mantis_issue)
        if ref:
            return ref.github_issue_markdown(github_target_issue)
        return self.mantis.issue_link_markdown(mantis_issue_id)

    def text_to_markdown(self, text, github_target_issue=None):
        # Remove leading blank lines.
        text = re.sub(r'^( *\n)+', '', text)
        # If it looks like a stack trace or log file, then preformat it.  Otherwise, remove
        # unintended Markdown effects.
        if (    len(re.findall(r'\bat .*\(.*\.java:[0-9]+\)', text)) > 3
            or  len(re.findall(r'^ *(DEBUG|WARN|INFO|ERROR):', text, flags=re.MULTILINE)) > 3
            or  len(re.findall(r'^ *[EWIDV]/', text, flags=re.MULTILINE)) > 3
            ):
            text = '```\n' + text + '\n```'
        else:
            text = re.subn(r'^ {4,}', '   ', text, flags=re.MULTILINE)[0]
            # Convert Mantis issue references (#N) into links to Mantis or to a GitHub issue
            # reference (#M, org/repo#M) if the Mantis issue appears to have been migrated.
            text = re.subn(r'#(\d+)', lambda match: self.mantis_issue_ref_markdown(int(match.group(1)), github_target_issue), text)[0]
            # Convert GitHub issue links to references.
            if github_target_issue:
                def replace_link(match):
                    org, repo, issuenum = match.group(1), match.group(2), int(match.group(3))
                    if org == github_target_issue.org_name and repo == github_target_issue.repo_name:
                        return '#%u' % issuenum
                    return '%s/%s#%u' % (org, repo, issuenum)
                text = re.subn(r'\bhttps?://github.com/([^\s/]+)/([^\s/]+)/issues/(\d+)\b', replace_link, text)[0]
        return text

    def filter_mantis_issues(self, mantis_issues):
        statuses = []
        if self.opts['--open']:
            statuses += ['new', 'assigned', 'acknowledged', 'confirmed', 'feedback']
        if self.opts['--closed']:
            statuses += ['resolved', 'closed']
        for issue in mantis_issues:
            if not statuses or issue.status.name in statuses:
                yield issue

def mantis_user_str(user):
    if not user:
        return 'None'
    r = [user.name]
    if user.real_name:
        r += [repr(user.real_name)]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def github_dump_issue(issue):
    print 'number', '=', issue.number
    print 'title', '=', issue.title
    print 'state', '=', issue.state
    print 'milestone', '=', github_milestone_str(issue.milestone)
    print 'labels', '=', ', '.join(label.name for label in issue.labels)
    print 'created_at', '=', issue.created_at
    print 'updated_at', '=', issue.updated_at
    print 'user', '=', github_user_str(issue.user)
    print 'assignee', '=', github_user_str(issue.assignee)
    print 'repository', '=', issue.repository
    print 'pull_request', '=', issue.pull_request.html_url if issue.pull_request else 'None'
    print 'id', '=', issue.id
    print 'html_url', '=', issue.html_url
    print 'url', '=', issue.url
    print 'closed_at', '=', issue.closed_at
    print 'closed_by', '=', github_user_str(issue.closed_by)
    print 'body', '=', issue.body
    print 'comments', '=', issue.comments
    if issue.comments:
        for i, comment in enumerate(issue.get_comments()):
            print '-------------------- comment', i + 1, '--------------------'
            github_dump_issue_comment(comment)

def github_dump_issue_comment(comment):
    print 'user', '=', github_user_str(comment.user)
    print 'created_at', '=', comment.created_at
    print 'updated_at', '=', comment.updated_at
    print 'id', '=', comment.id
    print 'url', '=', comment.url
    print 'body', '=', comment.body

def github_user_str(user):
    if not user:
        return 'None'
    r = [user.login]
    if user.name:
        r += [repr(user.name)]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def github_milestone_str(milestone):
    return '%s (%s) %s' % (milestone.number, milestone.due_on, milestone.title) if milestone else repr(milestone)

if __name__ == '__main__':
    main()
