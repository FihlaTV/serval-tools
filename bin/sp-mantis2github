#!/usr/bin/env python

'''Usage:
    sp-mantis2github [options] mantis version
    sp-mantis2github [options] mantis wsdl
    sp-mantis2github [options] mantis list users
    sp-mantis2github [options] mantis list projects
    sp-mantis2github [options] mantis list issues [<project-id>] [-C|--closed] [-O|--open]
    sp-mantis2github [options] mantis dump project <project-id>
    sp-mantis2github [options] mantis dump issue <issue-id>
    sp-mantis2github [options] github register
    sp-mantis2github [options] github list users
    sp-mantis2github [options] github list repos
    sp-mantis2github [options] github list issues <repo-name>
    sp-mantis2github [options] github dump issue <repo-name> <issue-number>
    sp-mantis2github [options] migrate <issue-id> <repo-name>
    sp-mantis2github -h | --help
    sp-mantis2github --version
Options:
    -h --help               Show this message
    --version               Show version and exit
    -D --debug              Enable debug logging
    -n --dry-run            Do not write to GitHub, just perform all queries
    --config=PATH           Read config file [default: $HOME/.mantis2github]
    --mantis-url=URL        Connect to Mantis SOAP service at this URL (default taken from
                            $SERVAL_MANTIS_URL/api/soap/mantisconnect.php if set, or config file)
    --mantis-user=USER      Connect to Mantis with this user name (overrides config file)
    --mantis-password=PASS  Connect to Mantis with this password (overrides config file)
    --github-login=USER     Connect to GitHub with this user name (overrides config file)
    --github-password=PASS  Connect to GitHub with this password (overrides config file)
    -C --closed             When listing issues, only include closed issues
    -O --open               When listing issues, only include open issues

The config file is in INI format.  It contains user names and passwords in the clear so it is
ignored unless owned by the caller and permissions are at most 0600.
'''

myname = 'sp-mantis2github'
myversion = '0.42'

import sys
import traceback
import os
import os.path
import logging
import ConfigParser
import datetime
import urllib2
import re

def main():
    logging.basicConfig(level=logging.INFO)
    logging.getLogger('suds').setLevel(logging.CRITICAL)
    sys.path.append(os.path.join(serval_tools_root(), "python/docopt"))
    sys.path.append(os.path.join(serval_tools_root(), "python/PyGithub"))
    import docopt
    import github
    cx = Context()
    cx.opts = docopt.docopt(__doc__, version=myversion)
    #print cx.opts
    cx.mantis.url = os.environ.get('SERVAL_MANTIS_URL')
    cx.read_config_file(os.path.expanduser(os.path.expandvars(cx.opts['--config'])))
    if cx.opts['--debug']:
        cx.debug = True
    cx.dry_run = cx.opts['--dry-run']
    cx.mantis.url = cx.opts['--mantis-url'] or cx.mantis.url
    cx.mantis.user = cx.opts['--mantis-user'] or cx.mantis.user
    cx.mantis.password = cx.opts['--mantis-password'] or cx.mantis.password
    cx.github.login = cx.opts['--github-login'] or cx.github.login
    cx.github.password = cx.opts['--github-password'] or cx.github.password
    if cx.debug:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.getLogger('suds').setLevel(logging.INFO)
    try:
        if cx.opts['mantis']:
            if cx.opts['wsdl']:
                print cx.mantis.client()
            elif cx.opts['version']:
                print cx.mantis.service('mc_version')
            elif cx.opts['list'] and cx.opts['projects']:
                projects = cx.mantis.service_cred('mc_projects_get_user_accessible')
                projects.sort(key=lambda p: p.id)
                for project in projects:
                    print '%-5s %-15s %-15s %-40s' % (project.id, project.status.name, project.view_state.name, project.name)
            elif cx.opts['dump'] and cx.opts['project']:
                try:
                    project_id = int(cx.opts['<project-id>'])
                except ValueError:
                    fatal('invalid <project-id>')
                projects = cx.mantis.service_cred('mc_projects_get_user_accessible')
                for project in projects:
                    if project.id == project_id:
                        print project
            elif cx.opts['dump'] and cx.opts['issue']:
                try:
                    issue_id = int(cx.opts['<issue-id>'])
                except ValueError:
                    fatal('invalid <issue-id>')
                print cx.mantis.service_cred('mc_issue_get', issue_id=issue_id)
            elif cx.opts['list'] and cx.opts['users']:
                all_issues = cx.mantis.get_issues()
                users = {}
                for issue in all_issues:
                    try:
                        users[issue.reporter.id] = issue.reporter
                    except AttributeError:
                        pass
                    try:
                        users[issue.handler.id] = issue.handler
                    except AttributeError:
                        pass
                users = users.values()
                users.sort(key=lambda u: (getattr(u, 'name', ''), getattr(u, 'real_name', '')))
                for user in users:
                    values = (getattr(user, 'name', ''), getattr(user, 'real_name', ''), getattr(user, 'email', ''))
                    if values != ('', '', ''):
                        print '%-20s %-30s %s' % values
            elif cx.opts['list'] and cx.opts['issues']:
                project_ids = []
                if cx.opts['<project-id>']:
                    try:
                        project_ids.append(int(cx.opts['<project-id>']))
                    except ValueError:
                        fatal('invalid <project-id>')
                all_issues = cx.mantis.get_issues(project_ids)
                all_issues.sort(key=lambda p: p.id)
                for issue in all_issues:
                    resolutions = []
                    if cx.opts['--open']:
                        resolutions += ['open', 'reopened']
                    if cx.opts['--closed']:
                        resolutions += ['fixed']
                    if resolutions and issue.resolution.name not in resolutions:
                        continue
                    print '%-5s %-10s %s' % (issue.id, issue.resolution.name, issue.summary)
        elif cx.opts['github']:
            if cx.opts['register']:
                root = cx.github.main().root()
                logging.debug('%s get_user()' % (cx.github.main().debugtag(),))
                ghuser = root.get_user()
                scopes = ['public_repo']
                note = myname + ' version ' + myversion
                logging.debug('%s create_authorization(scopes=%r, note=%r)' % (cx.github.main().debugtag(), scopes, note))
                if not cx.dry_run:
                    auth = ghuser.create_authorization(scopes=scopes, note=note)
                    print auth.token
            elif cx.opts['list'] and cx.opts['users']:
                org = cx.github.default_connection().org()
                logging.debug('%s get_members()' % (cx.github.default_connection(org=org).debugtag(),))
                users = list(org.get_members())
                users.sort(key=lambda u: (u.login, u.name))
                for user in users:
                    print '%-20s %-30s %s' % (user.login, user.name or '', user.email or '')
            elif cx.opts['list'] and cx.opts['repos']:
                org = cx.github.default_connection().org()
                logging.debug('%s get_repos()' % (cx.github.default_connection(org=org).debugtag(),))
                repos = org.get_repos()
                for repo in repos:
                    print repo.name
            elif cx.opts['list'] and cx.opts['issues']:
                repo_name = cx.opts['<repo-name>']
                repo = cx.github.default_connection().repo(repo_name)
                all_issues = []
                if cx.opts['--open'] or not cx.opts['--closed']:
                    logging.debug('%s get_issues(state="open")' % (cx.github.default_connection().debugtag(repo=repo),))
                    all_issues += repo.get_issues(state='open')
                if cx.opts['--closed'] or not cx.opts['--open']:
                    logging.debug('%s get_issues(state="closed")' % (cx.github.default_connection().debugtag(repo=repo),))
                    all_issues += repo.get_issues(state='closed')
                all_issues.sort(key=lambda p: p.number)
                for issue in all_issues:
                    print '%-5s %-10s %s' % (issue.number, issue.state, issue.title)
            elif cx.opts['dump'] and cx.opts['issue']:
                repo_name = cx.opts['<repo-name>']
                try:
                    issue_number = int(cx.opts['<issue-number>'])
                except ValueError:
                    fatal('invalid <issue-number>')
                repo = cx.github.default_connection().repo(repo_name)
                logging.debug('%s get_issue(%r)' % (cx.github.default_connection().debugtag(repo=repo), issue_number))
                github_dump_issue(repo.get_issue(issue_number))
        elif cx.opts['migrate']:
            try:
                issue_id = int(cx.opts['<issue-id>'])
            except ValueError:
                fatal('invalid <issue-id>')
            repo_name = cx.opts['<repo-name>']
            mantis_issue = cx.mantis.service_cred('mc_issue_get', issue_id=issue_id)
            mantis_issue_url = cx.mantis.url_base() + '/view.php?id=' + str(mantis_issue.id)
            mantis_issue_number = '%07u' % mantis_issue.id
            mantis_link = '[mantis:' + mantis_issue_number + '](' + mantis_issue_url + ')'
            creator_ghc, reporter_ref, reporter_tag = cx.resolve_user(mantis_issue.reporter)
            if creator_ghc is None:
                creator_ghc = cx.github.default_connection()
            repo = creator_ghc.repo(repo_name)
            label_name = 'mantis2github'
            label_colour = '034c31' # Mantis logo text colour
            label = None
            try:
                logging.debug('%s create_label(%r, %r)' % (creator_ghc.debugtag(repo=repo), label_name, label_colour))
                if not cx.dry_run:
                    label = repo.create_label(label_name, label_colour)
                #logging.debug('%s get_label(%r)' % (creator_ghc.debugtag(repo=repo), label_name))
                #label = repo.get_label(label_name)
            except github.GithubException, e:
                if e.status != 422:
                    raise
                logging.debug('%s get_label(%r)' % (creator_ghc.debugtag(repo=repo), label_name))
                label = repo.get_label(label_name)
                if label.color.lower() != label_colour:
                    logging.debug('%s label=%r edit(name=%r, color=%r)' % (creator_ghc.debugtag(repo=repo), label_name, label_name, label_colour))
                    if not cx.dry_run:
                        label.edit(label_name, label_colour)
            body = []
            if reporter_tag:
                body += [reporter_tag, ' reported:\n\n']
            body += [mantis_text_to_markdown(mantis_issue.description)]
            # This must be the first comment to make it easy to later detect and cross-reference Mantis
            # issues to GitHub issues.
            comments = [(creator_ghc,
                    'Originally reported as **' + mantis_link + '**' +
                    (' by ' + reporter_ref if reporter_ref else '') +
                    ' at ' + mantis_issue.date_submitted.ctime() + '.'
                )]
            github_assignee = cx.map_user(getattr(mantis_issue, 'handler', None))
            body += ['\n\nCan reproduce: **', mantis_issue.reproducibility.name, '**']
            if hasattr(mantis_issue, 'steps_to_reproduce') and mantis_issue.steps_to_reproduce:
                body += ['\n\nTo reproduce:\n\n', mantis_text_to_markdown(mantis_issue.steps_to_reproduce)]
            if hasattr(mantis_issue, 'additional_information') and mantis_issue.additional_information:
                body += ['\n\n' + mantis_text_to_markdown(mantis_issue.additional_information)]
            title = unicode(mantis_issue.summary)
            body = u''.join(body)
            if hasattr(mantis_issue, 'notes') and mantis_issue.notes:
                for note in mantis_issue.notes:
                    noter_ghc, noter_ref, noter_tag = cx.resolve_user(note.reporter)
                    note_body = []
                    note_body += ['At ', note.date_submitted.ctime()]
                    if noter_ghc is None:
                        noter_ghc = cx.github.default_connection()
                        note_body += [' ', noter_tag, ' commented']
                    else:
                        noter_tag = None
                    note_body += [':']
                    if hasattr(note, 'time_tracking') and note.time_tracking:
                        hours = note.time_tracking / 60
                        minutes = note.time_tracking % 60
                        note_body += ['\n\nTime spent: **%u:%02u**' % (hours, minutes)]
                    if hasattr(note, 'text') and note.text:
                        note_body += ['\n\n', mantis_text_to_markdown(note.text)]
                    comments.append((noter_ghc, ''.join(note_body)))
            resolution = getattr(getattr(mantis_issue, 'resolution', None), 'name', None)
            closemark = object()
            if resolution in ('open', 'reopened'):
                pass
            elif resolution in ('fixed'):
                comments.append((creator_ghc, 'Issue **closed** in Mantis at ' + mantis_issue.last_updated.ctime() + '.'))
                comments.append((creator_ghc, closemark))
            else:
                logging.warn('unknown Mantis resolution %r -- leaving issue open' % (resolution,))
            comments.append((cx.github.default_connection(),
                    'Issue migrated from Mantis to GitHub' +
                    ' at ' + datetime.datetime.now().ctime() +
                    ' using [' + myname + '](https://github.com/servalproject/serval-tools/blob/master/bin/' + myname + ') version ' + myversion + '.'
                ))
            logging.debug('%s create_issue(title=%r body=%r labels=[%s])' % (creator_ghc.debugtag(repo=repo), title, body, label_name))
            issue = None
            issue_number = None
            if not cx.dry_run:
                issue = repo.create_issue(title=title, body=body, labels=[label])
                issue_number = issue.number
            if github_assignee is not None:
                logging.debug('%s edit(assignee=%r)' % (creator_ghc.debugtag(issue=issue), github_assignee.login))
                if not cx.dry_run:
                    issue.edit(assignee=github_assignee)
                    if getattr(issue.assignee, 'login', None) != github_assignee.login:
                        logging.warn('cannot assign issue to %r -- adding GitHub comment instead' % (github_assignee.login,))
                        comments.insert(1, (cx.github.default_connection(), 'Assigned to Mantis user ' + mantis_user_markdown(mantis_issue.handler) + '.'))
            for commenter_ghc, comment_body in comments:
                commenter_repo = commenter_ghc.repo(repo_name)
                if comment_body is closemark:
                    logging.debug('%s edit(state="closed")' % (commenter_ghc.debugtag(repo=commenter_repo),))
                    if not cx.dry_run:
                        issue.edit(state='closed')
                        if issue.state != 'closed':
                            logging.warn('cannot close issue #%r' % (issue.number,))
                else:
                    logging.debug('%s get_issue(%r)' % (commenter_ghc.debugtag(repo=commenter_repo), issue_number))
                    if not cx.dry_run:
                        commenter_issue = commenter_repo.get_issue(issue_number)
                    logging.debug('%s issue=%r create_comment(%r)' % (commenter_ghc.debugtag(repo=commenter_repo), issue_number, comment_body))
                    if not cx.dry_run:
                        commenter_issue.create_comment(comment_body)
            # TODO: handle project
            # TODO: handle version and target version
            # TODO: handle severity
            # TODO: handle priority
            # TODO: handle tags
            # TODO: handle attachments (import as Gists?)
            # TODO: handle relationships (links between issues)
            #   - command to build map
            #   - cache map locally
            #   - command to edit comments referring to imported Mantis issues,
            #     to refer to GitHub issues instead
    except IOError, e:
        if cx.debug:
            traceback.print_exc()
        fatal('%s: %s' % (cx.mantis.url or '<Unknown URL>', e))
    except github.GithubException, e:
        if cx.debug:
            traceback.print_exc()
        fatal(e.data.get('message', 'Unknown error'))

def fatal(message):
    logging.critical(message)
    sys.exit(1)

def serval_tools_root():
    return os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))

class MantisInterface(object):
    url = None
    user = None
    password = None
    _client = None

    def read_config(self, cp):
        try:
            self.url = cp.get('mantis', 'url', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.user = cp.get('mantis', 'user', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.password = cp.get('mantis', 'password', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass

    def url_base(self):
        if not self.url:
            fatal("missing Mantis URL")
        try:
            return self.url[:self.url.index('/api/')]
        except ValueError:
            return self.url

    def url_soap(self):
        return self.url_base() + '/api/soap/mantisconnect.php?wsdl'

    def client(self):
        if not self._client:
            import suds
            url = self.url_soap()
            logging.debug('create Mantis SOAP client, url=%r' % (url,))
            self._client = suds.client.Client(url)
        return self._client

    def service(self, method, **kwargs):
        '''This method exists to create a single code path to invoking SOAP services, that can be
        logged.
        '''
        safe_kwargs = dict(kwargs)
        if 'password' in safe_kwargs:
            safe_kwargs['password'] = '***'
        import suds
        try:
            client = self.client()
            logging.debug('%s(%s)' % (method, ', '.join('%s=%s' % i for i in safe_kwargs.iteritems())))
            return getattr(client.service, method)(**kwargs)
        except suds.WebFault, e:
            if cx.debug:
                traceback.print_exc()
            fatal(e)

    def service_cred(self, method, **kwargs):
        _kwargs = dict(self.credentials())
        _kwargs.update(kwargs)
        return self.service(method, **_kwargs)

    def credentials(self):
        if self.user is None:
            fatal("missing Mantis user name")
        if self.password is None:
            fatal("missing Mantis password")
        return {'username': self.user, 'password': self.password}

    def get_issues(self, project_ids=None, per_page=100, **kwopts):
        if not project_ids:
            project_ids = []
            projects = self.service_cred('mc_projects_get_user_accessible', **kwopts)
            for project in projects:
                project_ids.append(project.id)
        all_issues = []
        for project_id in project_ids:
            page = 1
            while True:
                issues = self.service_cred('mc_project_get_issues', project_id=project_id, page_number=page, per_page=per_page, **kwopts)
                all_issues += issues
                if len(issues) < per_page:
                    break
                page += 1
        return all_issues

class GithubInterface(object):
    login = None
    password = None
    user_tokens = ()
    _main = None
    _connections = ()

    def read_config(self, cp):
        try:
            self.login = cp.get('github', 'login', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        try:
            self.password = cp.get('github', 'password', os.environ)
        except ConfigParser.NoSectionError:
            pass
        except ConfigParser.NoOptionError:
            pass
        self.user_tokens = {}
        try:
            for key, value in cp.items('github users'):
                self.user_tokens[key] = cp.get('github users', key, os.environ)
        except ConfigParser.NoSectionError:
            pass

    def main(self):
        if not self._main:
            self._main = GithubConnection()
            self._main.login = self.login
            self._main.password = self.password
        return self._main

    def connection(self, login):
        if not self._connections:
            self._connections = {}
        if login not in self._connections:
            conn = None
            if login in self.user_tokens:
                conn = GithubConnection()
                conn.login = login
                conn.token = self.user_tokens[login]
            self._connections[login] = conn
        return self._connections[login]

    def default_connection(self):
        return self.connection(self.login)

class GithubConnection(object):
    login = None
    password = None
    token = None
    org_name = 'servalproject'
    _root = None
    _org = None
    _repos = None

    def debugtag(self, org=None, repo=None, issue=None):
        if issue:
            repo = issue.repository
        if repo:
            org = repo.organization
        r = ['GitHub login=%r' % (self.login,)]
        if org:
            r += ['org=%r' % org.name]
        if repo:
            r += ['repo=%r' % repo.name]
        if issue:
            r += ['issue=%r' % issue.number]
        return ' '.join(r)

    def root(self):
        if not self._root:
            import github
            if self.password:
                logging.debug('connect to GitHub as %r using password' % (self.login,))
                self._root = github.Github(self.login, self.password)
            elif self.token:
                logging.debug('connect to GitHub as %r using token' % (self.login,))
                self._root = github.Github(self.token)
            else:
                fatal('missing GitHub password or token for login %r' % (self.login,))
        return self._root

    def org(self):
        if not self._org:
            root = self.root()
            logging.debug('%s get_organization(%r)' % (self.debugtag(), self.org_name))
            self._org = root.get_organization(self.org_name)
        return self._org

    def repo(self, name):
        if not self._repos:
            self._repos = {}
        if name not in self._repos:
            org = self.org()
            logging.debug('%s get_repo(%r)' % (self.debugtag(org=org), name))
            self._repos[name] = org.get_repo(name)
        return self._repos[name]

class Context(object):
    debug = False
    dry_run = False
    opts = None
    mantis = MantisInterface()
    github = GithubInterface()
    user_map = ()

    def read_config_file(self, path):
        if os.path.exists(path):
            stat = os.stat(path)
            if stat.st_uid != os.getuid():
                logging.warn("%s exists but is owned by uid %s (should be %s) -- ignored" % (path, stat.st_uid, getuid()))
            elif stat.st_mode & 0177:
                logging.warn("%s exists but has mode %#o (should be at most 0600) -- ignored" % (path, stat.st_mode & 0777))
            else:
                cp = ConfigParser.SafeConfigParser()
                cp.optionxform = str
                cp.readfp(file(path))
                self.mantis.read_config(cp)
                self.github.read_config(cp)
                self.user_map = {}
                try:
                    for key, value in cp.items('user map'):
                        self.user_map[key] = cp.get('user map', key, os.environ)
                except ConfigParser.NoSectionError:
                    pass

    def map_user(self, mantis_user):
        '''Convert a Mantis AccountData object into a GitHub NamedUser object.'''
        if mantis_user is None:
            return None
        login = self.user_map.get(mantis_user.name, None)
        if not login:
            return None
        conn = self.github.connection(login)
        if conn:
            return conn.get_user()
        return self.github.main().root().get_user(login)

    def resolve_user(self, mantis_account):
        login = self.user_map.get(mantis_account.name)
        ghc, ref, tag = None, None, None
        if login is None:
            ref = mantis_user_markdown(mantis_account)
            tag = mantis_user_details(mantis_account)
        else:
            ref = '@' + login
            tag = ref
            ghc = self.github.connection(login)
        logging.debug('resolved mantis user %r to %r %s' % (mantis_account.name, tag, '(auth)' if ghc else '(no auth)'))
        return ghc, ref, tag

def mantis_user_str(user):
    if not user:
        return 'None'
    r = [user.name]
    if user.real_name:
        r += [repr(user.real_name)]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def mantis_user_markdown(user):
    if not user:
        return 'None'
    r = ['**' + user.name + '**']
    d = mantis_user_details(user)
    if d:
        r += [d]
    return ' '.join(r)

def mantis_user_details(user):
    r = []
    if user.real_name:
        r += [user.real_name]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def github_dump_issue(issue):
    print 'number', '=', issue.number
    print 'title', '=', issue.title
    print 'state', '=', issue.state
    print 'milestone', '=', github_milestone_str(issue.milestone)
    print 'labels', '=', ', '.join(label.name for label in issue.labels)
    print 'created_at', '=', issue.created_at
    print 'updated_at', '=', issue.updated_at
    print 'user', '=', github_user_str(issue.user)
    print 'assignee', '=', github_user_str(issue.assignee)
    print 'repository', '=', issue.repository
    print 'pull_request', '=', issue.pull_request.html_url if issue.pull_request else 'None'
    print 'id', '=', issue.id
    print 'html_url', '=', issue.html_url
    print 'url', '=', issue.url
    print 'closed_at', '=', issue.closed_at
    print 'closed_by', '=', github_user_str(issue.closed_by)
    print 'body', '=', issue.body
    print 'comments', '=', issue.comments
    if issue.comments:
        for i, comment in enumerate(issue.get_comments()):
            print '-------------------- comment', i + 1, '--------------------'
            github_dump_issue_comment(comment)

def github_dump_issue_comment(comment):
    print 'user', '=', github_user_str(comment.user)
    print 'created_at', '=', comment.created_at
    print 'updated_at', '=', comment.updated_at
    print 'id', '=', comment.id
    print 'url', '=', comment.url
    print 'body', '=', comment.body

def github_user_str(user):
    if not user:
        return 'None'
    r = [user.login]
    if user.name:
        r += [repr(user.name)]
    if user.email:
        r += ['<%s>' % user.email]
    return ' '.join(r)

def github_milestone_str(milestone):
    return '%s (%s) %s' % (milestone.number, milestone.due_on, milestone.title) if milestone else 'None'

def mantis_text_to_markdown(text):
    # Remove leading blank lines.
    text = re.sub(r'^( *\n)+', '', text)
    # If it looks like a stack trace or log file, then preformat it.  Otherwise, remove
    # unintended Markdown effects.
    if (    len(re.findall(r'\bat .*\(.*\.java:[0-9]+\)', text)) > 3
        or  len(re.findall(r'^ *(DEBUG|WARN|INFO|ERROR):', text, flags=re.MULTILINE)) > 3
        or  len(re.findall(r'^ *[EWIDV]/', text, flags=re.MULTILINE)) > 3
        ):
        text = '```' + text + '\n```'
    else:
        text = re.subn(r'^ {4,}', '   ', text, flags=re.MULTILINE)[0]
    return text

def parse_mantis_xml(f):
    '''This is left-over code from an early attempt to parse the XML exported by Mantis.
    '''
    import lxml.etree
    import lxml.objectify
    tree = lxml.objectify.parse(f)
    root = tree.getroot()
    for issue in root.iterchildren():
        if issue.status != 'closed':
            print issue.id, issue.summary

if __name__ == '__main__':
    main()
